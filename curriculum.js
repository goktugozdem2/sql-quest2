window.sqlCurriculum={title:"Master SQL 30-Days Challenge",description:"Transform from SQL beginner to expert in 30 days with our structured curriculum",weeks:[{id:1,title:"SQL for Data Analysis",subtitle:"Days 01-07",color:"from-blue-500 to-cyan-500",icon:"ðŸ“Š",days:[{day:1,title:"Introduction to SQL",description:"Learn what SQL is, why it matters, and write your first query",concepts:["SELECT","FROM","Basic Syntax"],lesson:{content:"# Welcome to SQL! ðŸŽ‰\n\nSQL (Structured Query Language) is the standard language for working with databases. Every tech company uses it!\n\n## Your First Query\n\nThe most basic SQL statement retrieves data from a table:\n\n```sql\nSELECT * FROM employees;\n```\n\nThis returns ALL columns (*) from the employees table.\n\n## Selecting Specific Columns\n\n```sql\nSELECT name, salary FROM employees;\n```\n\nThis returns only the name and salary columns.",keyPoints:["SQL is used to communicate with databases","SELECT retrieves data from tables","* means 'all columns'","Always end statements with semicolon"]},challenge:{title:"Your First SELECT",description:"Write a query to select all columns from the **passengers** table in the Titanic dataset.",dataset:"titanic",solution:"SELECT * FROM passengers;",hints:["Use SELECT * to get all columns","The table name is 'passengers'"],points:10}},{day:2,title:"Understanding Databases and Tables",description:"Learn how data is organized in databases, tables, rows, and columns",concepts:["Tables","Rows","Columns","Data Types"],lesson:{content:"# Database Structure ðŸ—„ï¸\n\n## How Data is Organized\n\n- **Database**: A collection of related tables\n- **Table**: A collection of related data (like a spreadsheet)\n- **Row**: A single record (one passenger, one sale, etc.)\n- **Column**: A specific attribute (name, age, price, etc.)\n\n## Common Data Types\n\n| Type | Example | Use For |\n|------|---------|---------|\n| INTEGER | 42 | Whole numbers |\n| REAL/FLOAT | 3.14 | Decimal numbers |\n| TEXT | 'John' | Words and strings |\n| DATE | '2024-01-15' | Dates |\n\n## Viewing Table Structure\n\n```sql\nPRAGMA table_info(passengers);\n```",keyPoints:["Tables organize data into rows and columns","Each column has a specific data type","Rows represent individual records","Good table design is crucial for efficiency"]},challenge:{title:"Explore the Data",description:"Select only the **Name**, **Age**, and **Fare** columns from the passengers table.",dataset:"titanic",solution:"SELECT Name, Age, Fare FROM passengers;",hints:["List column names separated by commas","Column names are case-sensitive"],points:10}},{day:3,title:"SELECT Statement",description:"Master the SELECT statement with column selection and aliases",concepts:["SELECT","Column Aliases","DISTINCT"],lesson:{content:"# Mastering SELECT ðŸŽ¯\n\n## Column Aliases\n\nGive columns friendlier names in your output:\n\n```sql\nSELECT Name AS passenger_name, \n       Fare AS ticket_price \nFROM passengers;\n```\n\n## Removing Duplicates\n\nUse DISTINCT to get unique values:\n\n```sql\nSELECT DISTINCT Pclass FROM passengers;\n```\n\nThis shows each class only once (1, 2, 3).\n\n## Combining Techniques\n\n```sql\nSELECT DISTINCT Embarked AS boarding_port \nFROM passengers;\n```",keyPoints:["AS creates column aliases for cleaner output","DISTINCT removes duplicate rows","Aliases don't change the actual data","You can alias multiple columns in one query"]},challenge:{title:"Distinct Values",description:"Find all unique **passenger classes** (Pclass) in the Titanic dataset. Use an alias to name the column 'class'.",dataset:"titanic",solution:"SELECT DISTINCT Pclass AS class FROM passengers;",hints:["Use DISTINCT before the column name","Use AS to create the alias"],points:15}},{day:4,title:"WHERE Clause and Logical Operators",description:"Filter data using conditions with WHERE, AND, OR, and comparison operators",concepts:["WHERE","AND","OR","Comparison Operators"],lesson:{content:"# Filtering with WHERE ðŸ”\n\n## Basic Filtering\n\n```sql\nSELECT * FROM passengers \nWHERE Age > 30;\n```\n\n## Comparison Operators\n\n| Operator | Meaning |\n|----------|---------|\n| = | Equal to |\n| != or <> | Not equal to |\n| > | Greater than |\n| < | Less than |\n| >= | Greater than or equal |\n| <= | Less than or equal |\n\n## Combining Conditions\n\n**AND** - Both conditions must be true:\n```sql\nSELECT * FROM passengers \nWHERE Age > 30 AND Survived = 1;\n```\n\n**OR** - Either condition can be true:\n```sql\nSELECT * FROM passengers \nWHERE Pclass = 1 OR Pclass = 2;\n```",keyPoints:["WHERE filters rows based on conditions","AND requires ALL conditions to be true","OR requires ANY condition to be true","Use parentheses to group complex conditions"]},challenge:{title:"Filter Survivors",description:"Find all **female passengers** who **survived**. Select their Name, Age, and Fare.",dataset:"titanic",solution:"SELECT Name, Age, Fare FROM passengers WHERE Sex = 'female' AND Survived = 1;",hints:["Sex column contains 'male' or 'female'","Survived = 1 means they survived"],points:15}},{day:5,title:"Sorting Data with ORDER BY",description:"Learn to sort query results in ascending or descending order",concepts:["ORDER BY","ASC","DESC","Multiple Sorts"],lesson:{content:"# Sorting Results ðŸ“ˆ\n\n## Basic Sorting\n\n```sql\nSELECT * FROM passengers \nORDER BY Age;\n```\n\nBy default, ORDER BY sorts in **ascending** order (smallest to largest).\n\n## Descending Order\n\n```sql\nSELECT * FROM passengers \nORDER BY Fare DESC;\n```\n\n## Multiple Sort Columns\n\n```sql\nSELECT * FROM passengers \nORDER BY Pclass ASC, Fare DESC;\n```\n\nThis sorts by class first, then by fare within each class.\n\n## Sorting with NULL Values\n\nNULL values typically appear first when sorting ASC, last when DESC.",keyPoints:["ORDER BY sorts results (ASC is default)","DESC sorts from largest to smallest","You can sort by multiple columns","Sorting happens after WHERE filtering"]},challenge:{title:"Top Fares",description:"Find the **10 highest fares** paid. Show Name, Pclass, and Fare, sorted from highest to lowest fare.",dataset:"titanic",solution:"SELECT Name, Pclass, Fare FROM passengers ORDER BY Fare DESC LIMIT 10;",hints:["Use ORDER BY with DESC","Use LIMIT to restrict to 10 rows"],points:15}},{day:6,title:"LIMIT & OFFSET",description:"Control how many rows are returned and implement pagination",concepts:["LIMIT","OFFSET","Pagination"],lesson:{content:"# Limiting Results ðŸ“„\n\n## Basic LIMIT\n\n```sql\nSELECT * FROM passengers LIMIT 5;\n```\n\nReturns only the first 5 rows.\n\n## OFFSET for Pagination\n\n```sql\nSELECT * FROM passengers \nLIMIT 10 OFFSET 20;\n```\n\nSkips the first 20 rows, then returns 10.\n\n## Pagination Pattern\n\nPage 1: `LIMIT 10 OFFSET 0`\nPage 2: `LIMIT 10 OFFSET 10`\nPage 3: `LIMIT 10 OFFSET 20`\n\nFormula: OFFSET = (page_number - 1) Ã— page_size\n\n## Combining with ORDER BY\n\n```sql\nSELECT * FROM passengers \nORDER BY Age DESC \nLIMIT 5;\n```\n\nGets the 5 oldest passengers.",keyPoints:["LIMIT restricts the number of rows returned","OFFSET skips a specified number of rows","ORDER BY + LIMIT finds top/bottom N records","Pagination uses LIMIT with calculated OFFSET"]},challenge:{title:"Pagination Practice",description:"Get the **second page** of passengers (rows 11-20) when showing 10 per page, sorted by Name alphabetically.",dataset:"titanic",solution:"SELECT * FROM passengers ORDER BY Name ASC LIMIT 10 OFFSET 10;",hints:["Page 2 means OFFSET 10","LIMIT 10 for 10 items per page"],points:15}},{day:7,title:"Aggregate Functions",description:"Calculate totals, averages, counts, and other aggregates",concepts:["COUNT","SUM","AVG","MIN","MAX"],lesson:{content:"# Aggregate Functions ðŸ”¢\n\n## COUNT - Count Rows\n\n```sql\nSELECT COUNT(*) FROM passengers;\n-- Total passengers\n\nSELECT COUNT(Age) FROM passengers;\n-- Passengers with known age (excludes NULL)\n```\n\n## SUM & AVG - Totals and Averages\n\n```sql\nSELECT SUM(Fare) AS total_revenue FROM passengers;\nSELECT AVG(Age) AS average_age FROM passengers;\n```\n\n## MIN & MAX - Extremes\n\n```sql\nSELECT MIN(Age) AS youngest, \n       MAX(Age) AS oldest \nFROM passengers;\n```\n\n## Combining Aggregates\n\n```sql\nSELECT \n  COUNT(*) AS total,\n  AVG(Fare) AS avg_fare,\n  SUM(Survived) AS survivors\nFROM passengers;\n```",keyPoints:["COUNT(*) counts all rows, COUNT(column) excludes NULLs","SUM adds up numeric values","AVG calculates the mean","MIN/MAX find extreme values"]},challenge:{title:"Survival Statistics",description:"Calculate the **total passengers**, **survivors count**, and **average fare** for the entire dataset.",dataset:"titanic",solution:"SELECT COUNT(*) AS total_passengers, SUM(Survived) AS survivors, AVG(Fare) AS average_fare FROM passengers;",hints:["Use COUNT(*) for total","SUM(Survived) counts survivors (1=survived)"],points:20}}]},{id:2,title:"Intermediate SQL",subtitle:"Days 08-14",color:"from-purple-500 to-pink-500",icon:"ðŸš€",days:[{day:8,title:"GROUP BY Clause",description:"Group data and calculate aggregates per group",concepts:["GROUP BY","Aggregates with Groups"],lesson:{content:"# Grouping Data ðŸ“Š\n\n## Basic GROUP BY\n\n```sql\nSELECT Pclass, COUNT(*) AS passengers\nFROM passengers\nGROUP BY Pclass;\n```\n\nReturns count of passengers in each class.\n\n## Multiple Aggregates per Group\n\n```sql\nSELECT Pclass,\n       COUNT(*) AS total,\n       AVG(Age) AS avg_age,\n       SUM(Survived) AS survivors\nFROM passengers\nGROUP BY Pclass;\n```\n\n## Group by Multiple Columns\n\n```sql\nSELECT Pclass, Sex, AVG(Fare) AS avg_fare\nFROM passengers\nGROUP BY Pclass, Sex;\n```",keyPoints:["GROUP BY creates groups of rows with same values","Aggregate functions calculate per group","Non-aggregated columns must be in GROUP BY","You can group by multiple columns"]},challenge:{title:"Class Statistics",description:"Find the **survival rate** and **average fare** for each passenger **class**.",dataset:"titanic",solution:"SELECT Pclass, AVG(Survived) AS survival_rate, AVG(Fare) AS avg_fare FROM passengers GROUP BY Pclass;",hints:["AVG(Survived) gives survival rate (0-1)","GROUP BY Pclass"],points:20}},{day:9,title:"HAVING Clause",description:"Filter grouped data using HAVING",concepts:["HAVING","WHERE vs HAVING"],lesson:{content:"# Filtering Groups with HAVING ðŸŽ¯\n\n## WHERE vs HAVING\n\n- **WHERE**: Filters individual rows BEFORE grouping\n- **HAVING**: Filters groups AFTER aggregation\n\n## Example\n\n```sql\nSELECT Embarked, COUNT(*) AS passengers\nFROM passengers\nWHERE Age > 18\nGROUP BY Embarked\nHAVING COUNT(*) > 100;\n```\n\nThis query:\n1. Filters to adults only (WHERE)\n2. Groups by embarkation port\n3. Only shows ports with 100+ adults (HAVING)\n\n## Common Pattern\n\n```sql\nSELECT category, AVG(value) AS avg_val\nFROM data\nGROUP BY category\nHAVING AVG(value) > 50;\n```",keyPoints:["HAVING filters after GROUP BY","WHERE filters before GROUP BY","HAVING can use aggregate functions","WHERE cannot use aggregates"]},challenge:{title:"Popular Ports",description:"Find embarkation ports (**Embarked**) with more than **200 passengers**. Show the port and count.",dataset:"titanic",solution:"SELECT Embarked, COUNT(*) AS passenger_count FROM passengers GROUP BY Embarked HAVING COUNT(*) > 200;",hints:["GROUP BY Embarked","Use HAVING with COUNT(*)"],points:20}},{day:10,title:"JOINs (INNER, LEFT, RIGHT)",description:"Combine data from multiple tables using different join types",concepts:["INNER JOIN","LEFT JOIN","RIGHT JOIN"],lesson:{content:"# Joining Tables ðŸ”—\n\n## INNER JOIN\n\nReturns only matching rows from both tables:\n\n```sql\nSELECT e.name, d.department_name\nFROM employees e\nINNER JOIN departments d ON e.dept_id = d.id;\n```\n\n## LEFT JOIN\n\nReturns ALL rows from left table, matching from right:\n\n```sql\nSELECT e.name, d.department_name\nFROM employees e\nLEFT JOIN departments d ON e.dept_id = d.id;\n```\n\nEmployees without departments will show NULL.\n\n## RIGHT JOIN\n\nReturns ALL rows from right table, matching from left.\n\n## Visual Guide\n\n| Join Type | Left Only | Match | Right Only |\n|-----------|-----------|-------|------------|\n| INNER     | âŒ | âœ… | âŒ |\n| LEFT      | âœ… | âœ… | âŒ |\n| RIGHT     | âŒ | âœ… | âœ… |",keyPoints:["INNER JOIN returns only matching rows","LEFT JOIN includes all left table rows","RIGHT JOIN includes all right table rows","Use table aliases (e, d) for cleaner queries"]},challenge:{title:"Join Practice",description:"Using the **ecommerce** dataset, join **orders** with **customers** to show customer names with their order totals.",dataset:"ecommerce",solution:"SELECT c.name, o.total FROM orders o INNER JOIN customers c ON o.customer_id = c.id;",hints:["Join on customer_id = id","Use table aliases"],points:25}},{day:11,title:"Subqueries",description:"Use queries within queries for complex data retrieval",concepts:["Subqueries","IN","EXISTS"],lesson:{content:"# Subqueries ðŸŽ­\n\n## Subquery in WHERE\n\n```sql\nSELECT * FROM passengers\nWHERE Fare > (SELECT AVG(Fare) FROM passengers);\n```\n\nFinds passengers who paid more than average.\n\n## Subquery with IN\n\n```sql\nSELECT * FROM passengers\nWHERE Pclass IN (\n  SELECT Pclass FROM passengers\n  GROUP BY Pclass\n  HAVING AVG(Survived) > 0.5\n);\n```\n\n## Subquery in SELECT\n\n```sql\nSELECT Name, Fare,\n  (SELECT AVG(Fare) FROM passengers) AS avg_fare\nFROM passengers;\n```\n\n## Correlated Subquery\n\n```sql\nSELECT * FROM passengers p1\nWHERE Fare > (\n  SELECT AVG(Fare) FROM passengers p2\n  WHERE p2.Pclass = p1.Pclass\n);\n```",keyPoints:["Subqueries are queries inside queries","Use parentheses around subqueries","IN checks if value is in subquery results","Correlated subqueries reference outer query"]},challenge:{title:"Above Average",description:"Find passengers who paid a fare **higher than the average fare for their class**.",dataset:"titanic",solution:"SELECT * FROM passengers p1 WHERE Fare > (SELECT AVG(Fare) FROM passengers p2 WHERE p2.Pclass = p1.Pclass);",hints:["Use a correlated subquery","Match Pclass in subquery"],points:25}},{day:12,title:"Working with CASE Statements",description:"Add conditional logic to your queries",concepts:["CASE","WHEN","THEN","ELSE"],lesson:{content:"# Conditional Logic with CASE ðŸ”€\n\n## Basic CASE\n\n```sql\nSELECT Name,\n  CASE \n    WHEN Age < 18 THEN 'Child'\n    WHEN Age < 65 THEN 'Adult'\n    ELSE 'Senior'\n  END AS age_group\nFROM passengers;\n```\n\n## CASE in Aggregates\n\n```sql\nSELECT \n  SUM(CASE WHEN Survived = 1 THEN 1 ELSE 0 END) AS survived,\n  SUM(CASE WHEN Survived = 0 THEN 1 ELSE 0 END) AS died\nFROM passengers;\n```\n\n## Simple CASE Form\n\n```sql\nSELECT Name,\n  CASE Pclass\n    WHEN 1 THEN 'First Class'\n    WHEN 2 THEN 'Second Class'\n    WHEN 3 THEN 'Third Class'\n  END AS class_name\nFROM passengers;\n```",keyPoints:["CASE provides if-then-else logic","Each WHEN is checked in order","ELSE handles unmatched cases","CASE can be used anywhere an expression is valid"]},challenge:{title:"Fare Categories",description:"Create a query that categorizes fares as 'Budget' (< 20), 'Standard' (20-100), or 'Premium' (> 100). Show Name and the category.",dataset:"titanic",solution:"SELECT Name, CASE WHEN Fare < 20 THEN 'Budget' WHEN Fare <= 100 THEN 'Standard' ELSE 'Premium' END AS fare_category FROM passengers;",hints:["Use CASE WHEN for each range","Check conditions in order"],points:20}},{day:13,title:"Self-Joins",description:"Join a table to itself for hierarchical or comparative queries",concepts:["Self-Join","Table Aliases"],lesson:{content:"# Self-Joins ðŸ”„\n\nA self-join joins a table to itself, useful for:\n- Hierarchical data (employees â†’ managers)\n- Comparing rows within the same table\n\n## Example: Find Employees and Their Managers\n\n```sql\nSELECT \n  e.name AS employee,\n  m.name AS manager\nFROM employees e\nLEFT JOIN employees m ON e.manager_id = m.id;\n```\n\n## Comparing Rows\n\nFind passengers who paid the same fare:\n\n```sql\nSELECT p1.Name, p2.Name, p1.Fare\nFROM passengers p1\nINNER JOIN passengers p2 \n  ON p1.Fare = p2.Fare \n  AND p1.PassengerId < p2.PassengerId;\n```\n\nThe `<` prevents duplicate pairs.",keyPoints:["Self-joins require different aliases for the same table","Useful for hierarchical relationships","Use inequality to avoid duplicate pairs","LEFT JOIN keeps rows without matches"]},challenge:{title:"Same Cabin",description:"Find pairs of passengers who shared the same **Cabin** (non-empty). Show both names and the cabin.",dataset:"titanic",solution:"SELECT p1.Name AS passenger1, p2.Name AS passenger2, p1.Cabin FROM passengers p1 INNER JOIN passengers p2 ON p1.Cabin = p2.Cabin AND p1.PassengerId < p2.PassengerId WHERE p1.Cabin != '';",hints:["Join passengers to itself","Use < to avoid duplicates","Filter out empty cabins"],points:25}},{day:14,title:"UNION & UNION ALL",description:"Combine results from multiple queries",concepts:["UNION","UNION ALL","Set Operations"],lesson:{content:"# Combining Results ðŸ”—\n\n## UNION\n\nCombines results and removes duplicates:\n\n```sql\nSELECT Name FROM passengers WHERE Pclass = 1\nUNION\nSELECT Name FROM passengers WHERE Survived = 1;\n```\n\n## UNION ALL\n\nCombines results and keeps ALL rows (faster):\n\n```sql\nSELECT 'Class 1' AS source, COUNT(*) AS count \nFROM passengers WHERE Pclass = 1\nUNION ALL\nSELECT 'Survivors', COUNT(*) \nFROM passengers WHERE Survived = 1;\n```\n\n## Rules\n\n- Same number of columns\n- Compatible data types\n- Column names from first query\n\n## Use Cases\n\n- Combining data from multiple sources\n- Creating summary reports\n- Merging historical and current data",keyPoints:["UNION removes duplicates, UNION ALL keeps all","All queries must have same number of columns","Column names come from first SELECT","UNION ALL is faster (no deduplication)"]},challenge:{title:"Combined Report",description:"Create a report showing counts with labels: 'First Class' count, 'Second Class' count, and 'Third Class' count using UNION ALL.",dataset:"titanic",solution:"SELECT 'First Class' AS class, COUNT(*) AS count FROM passengers WHERE Pclass = 1 UNION ALL SELECT 'Second Class', COUNT(*) FROM passengers WHERE Pclass = 2 UNION ALL SELECT 'Third Class', COUNT(*) FROM passengers WHERE Pclass = 3;",hints:["Three SELECT statements with UNION ALL","Add a label column to each"],points:20}}]},{id:3,title:"Advanced SQL",subtitle:"Days 15-21",color:"from-orange-500 to-red-500",icon:"ðŸ”¥",days:[{day:15,title:"Understanding Indexes",description:"Learn how indexes speed up queries and when to use them",concepts:["Indexes","CREATE INDEX","Query Optimization"],lesson:{content:"# Database Indexes ðŸƒ\n\n## What is an Index?\n\nAn index is like a book's index - it helps find data faster without scanning every row.\n\n## Creating an Index\n\n```sql\nCREATE INDEX idx_passengers_class \nON passengers(Pclass);\n```\n\n## Composite Index\n\n```sql\nCREATE INDEX idx_passengers_class_survived \nON passengers(Pclass, Survived);\n```\n\n## When to Use Indexes\n\nâœ… Columns used in WHERE clauses\nâœ… Columns used in JOIN conditions\nâœ… Columns used in ORDER BY\n\nâŒ Small tables\nâŒ Columns with few unique values\nâŒ Tables with frequent inserts/updates\n\n## Viewing Indexes\n\n```sql\nPRAGMA index_list(passengers);\n```",keyPoints:["Indexes speed up SELECT queries","They slow down INSERT/UPDATE/DELETE","Choose indexed columns wisely","Composite indexes help multi-column queries"]},challenge:{title:"Index Strategy",description:"Create an index on the **Embarked** column, then write a query that would benefit from it.",dataset:"titanic",solution:"CREATE INDEX idx_embarked ON passengers(Embarked); SELECT * FROM passengers WHERE Embarked = 'S';",hints:["CREATE INDEX idx_name ON table(column)","Then query using that column in WHERE"],points:20}},{day:16,title:"Working with Views",description:"Create virtual tables for reusable query logic",concepts:["CREATE VIEW","Virtual Tables","Abstraction"],lesson:{content:"# Database Views ðŸ‘ï¸\n\n## What is a View?\n\nA view is a saved query that acts like a virtual table.\n\n## Creating a View\n\n```sql\nCREATE VIEW survivors AS\nSELECT Name, Age, Pclass, Fare\nFROM passengers\nWHERE Survived = 1;\n```\n\n## Using a View\n\n```sql\nSELECT * FROM survivors WHERE Age > 50;\n```\n\n## Benefits\n\n- **Simplicity**: Complex queries become simple\n- **Security**: Hide sensitive columns\n- **Consistency**: Same logic everywhere\n- **Maintenance**: Update once, use everywhere\n\n## Dropping a View\n\n```sql\nDROP VIEW IF EXISTS survivors;\n```",keyPoints:["Views are saved queries, not stored data","They simplify complex queries","Views can be queried like regular tables","Changes to base tables reflect in views"]},challenge:{title:"Create a View",description:"Create a view called **first_class_passengers** that shows Name, Age, and Fare for Pclass = 1. Then query it.",dataset:"titanic",solution:"CREATE VIEW first_class_passengers AS SELECT Name, Age, Fare FROM passengers WHERE Pclass = 1; SELECT * FROM first_class_passengers;",hints:["CREATE VIEW name AS SELECT...","Then SELECT from the view"],points:20}},{day:17,title:"Transaction Management",description:"Ensure data integrity with transactions",concepts:["BEGIN","COMMIT","ROLLBACK","ACID"],lesson:{content:"# Transactions ðŸ”\n\n## What is a Transaction?\n\nA transaction is a group of operations that either ALL succeed or ALL fail.\n\n## ACID Properties\n\n- **Atomicity**: All or nothing\n- **Consistency**: Valid state before and after\n- **Isolation**: Transactions don't interfere\n- **Durability**: Committed changes persist\n\n## Transaction Syntax\n\n```sql\nBEGIN TRANSACTION;\n\nUPDATE accounts SET balance = balance - 100 \nWHERE id = 1;\n\nUPDATE accounts SET balance = balance + 100 \nWHERE id = 2;\n\nCOMMIT;\n```\n\n## Rollback on Error\n\n```sql\nBEGIN TRANSACTION;\n-- operations...\nROLLBACK; -- Undo all changes\n```",keyPoints:["Transactions group related operations","COMMIT saves all changes","ROLLBACK undoes all changes","Essential for data integrity"]},challenge:{title:"Safe Update",description:"Write a transaction that updates a passenger's fare and class atomically. Use BEGIN and COMMIT.",dataset:"titanic",solution:"BEGIN TRANSACTION; UPDATE passengers SET Fare = 100, Pclass = 1 WHERE PassengerId = 1; COMMIT;",hints:["Start with BEGIN TRANSACTION","End with COMMIT"],points:20}},{day:18,title:"Creating Stored Procedures",description:"Learn about reusable SQL code blocks (conceptual in SQLite)",concepts:["Procedures","Functions","Reusability"],lesson:{content:"# Stored Procedures & Functions ðŸ“¦\n\n## What are Stored Procedures?\n\nReusable blocks of SQL code stored in the database.\n\nNote: SQLite has limited support, but the concepts apply to all databases.\n\n## SQLite User Functions (Conceptual)\n\nIn production databases like PostgreSQL/MySQL:\n\n```sql\nCREATE PROCEDURE GetSurvivorsByClass(class_id INT)\nBEGIN\n  SELECT * FROM passengers \n  WHERE Pclass = class_id AND Survived = 1;\nEND;\n\nCALL GetSurvivorsByClass(1);\n```\n\n## Benefits\n\n- **Reusability**: Write once, use many times\n- **Security**: Control data access\n- **Performance**: Pre-compiled execution\n- **Maintainability**: Centralized logic\n\n## SQLite Alternative: Views\n\n```sql\nCREATE VIEW class_survivors AS\nSELECT Pclass, COUNT(*) as survivors\nFROM passengers WHERE Survived = 1\nGROUP BY Pclass;\n```",keyPoints:["Stored procedures encapsulate SQL logic","They accept parameters for flexibility","In SQLite, use views for similar functionality","Production databases have full procedure support"]},challenge:{title:"Reusable Query",description:"Create a view that mimics a procedure: show survival statistics (count, avg_age, avg_fare) grouped by Pclass.",dataset:"titanic",solution:"CREATE VIEW class_statistics AS SELECT Pclass, COUNT(*) AS total, SUM(Survived) AS survivors, AVG(Age) AS avg_age, AVG(Fare) AS avg_fare FROM passengers GROUP BY Pclass; SELECT * FROM class_statistics;",hints:["Create a view with GROUP BY","Include multiple aggregates"],points:25}},{day:19,title:"Implementing Triggers",description:"Automate actions when data changes",concepts:["Triggers","AFTER INSERT","BEFORE UPDATE"],lesson:{content:"# Database Triggers âš¡\n\n## What is a Trigger?\n\nAutomatic code that runs when data changes.\n\n## Creating a Trigger\n\n```sql\nCREATE TRIGGER log_fare_update\nAFTER UPDATE ON passengers\nFOR EACH ROW\nWHEN OLD.Fare != NEW.Fare\nBEGIN\n  INSERT INTO fare_log(passenger_id, old_fare, new_fare, changed_at)\n  VALUES (NEW.PassengerId, OLD.Fare, NEW.Fare, datetime('now'));\nEND;\n```\n\n## Trigger Types\n\n- **BEFORE**: Runs before the operation\n- **AFTER**: Runs after the operation\n- **INSTEAD OF**: Replaces the operation (for views)\n\n## OLD and NEW\n\n- **OLD**: The row before change\n- **NEW**: The row after change",keyPoints:["Triggers automate database tasks","They fire on INSERT, UPDATE, or DELETE","OLD/NEW reference row values","Use for auditing, validation, cascading changes"]},challenge:{title:"Audit Trail",description:"Create an audit table and a trigger that logs whenever a passenger's Survived status is updated.",dataset:"titanic",solution:"CREATE TABLE IF NOT EXISTS survival_log (id INTEGER PRIMARY KEY, passenger_id INTEGER, old_status INTEGER, new_status INTEGER, changed_at TEXT); CREATE TRIGGER log_survival AFTER UPDATE ON passengers WHEN OLD.Survived != NEW.Survived BEGIN INSERT INTO survival_log(passenger_id, old_status, new_status, changed_at) VALUES (NEW.PassengerId, OLD.Survived, NEW.Survived, datetime('now')); END;",hints:["First CREATE TABLE for logs","Then CREATE TRIGGER AFTER UPDATE"],points:30}},{day:20,title:"Database Normalization",description:"Design efficient database structures",concepts:["1NF","2NF","3NF","Normalization"],lesson:{content:'# Database Normalization ðŸ“\n\n## Why Normalize?\n\n- Eliminate redundant data\n- Prevent update anomalies\n- Ensure data integrity\n\n## First Normal Form (1NF)\n\n- Each cell contains single value\n- Each row is unique\n- No repeating groups\n\nâŒ Bad: `hobbies: "reading, gaming"`\nâœ… Good: Separate hobbies table\n\n## Second Normal Form (2NF)\n\n- Meet 1NF\n- All non-key columns depend on the FULL primary key\n\n## Third Normal Form (3NF)\n\n- Meet 2NF\n- No transitive dependencies\n\nâŒ Bad: `employee_id, department_id, department_name`\nâœ… Good: Separate departments table\n\n## Denormalization\n\nSometimes we intentionally denormalize for performance (read-heavy systems).',keyPoints:["Normalization reduces data redundancy","1NF: Atomic values, unique rows","2NF: Full dependency on primary key","3NF: No transitive dependencies"]},challenge:{title:"Normalize Design",description:"The passengers table has Ticket shared by multiple passengers. Write a query to find all unique tickets with passenger count.",dataset:"titanic",solution:"SELECT Ticket, COUNT(*) AS passengers_on_ticket FROM passengers WHERE Ticket != '' GROUP BY Ticket HAVING COUNT(*) > 1 ORDER BY passengers_on_ticket DESC;",hints:["GROUP BY Ticket","Use HAVING to filter groups"],points:20}},{day:21,title:"Exploring ACID Properties",description:"Deep dive into database reliability guarantees",concepts:["Atomicity","Consistency","Isolation","Durability"],lesson:{content:"# ACID Properties ðŸ›¡ï¸\n\n## Atomicity\n\nAll operations in a transaction succeed or all fail.\n\n```sql\nBEGIN;\nUPDATE account SET balance = balance - 100 WHERE id = 1;\nUPDATE account SET balance = balance + 100 WHERE id = 2;\n-- If either fails, both are rolled back\nCOMMIT;\n```\n\n## Consistency\n\nDatabase moves from one valid state to another.\n\n## Isolation\n\nConcurrent transactions don't interfere.\n\n### Isolation Levels:\n1. READ UNCOMMITTED (lowest)\n2. READ COMMITTED\n3. REPEATABLE READ\n4. SERIALIZABLE (highest)\n\n## Durability\n\nOnce committed, data survives crashes.\n\n## Testing Atomicity\n\n```sql\nBEGIN;\nUPDATE passengers SET Fare = -100 WHERE PassengerId = 1;\n-- Check constraint would fail\nROLLBACK;\n```",keyPoints:["ACID ensures reliable transactions","Atomicity: All or nothing","Isolation levels trade performance for safety","Durability means committed = permanent"]},challenge:{title:"Transaction Practice",description:"Write a transaction that swaps fares between two passengers (ID 1 and 2), ensuring atomicity.",dataset:"titanic",solution:"BEGIN; UPDATE passengers SET Fare = (SELECT Fare FROM passengers WHERE PassengerId = 2) WHERE PassengerId = 1; UPDATE passengers SET Fare = (SELECT Fare FROM passengers WHERE PassengerId = 1) WHERE PassengerId = 2; COMMIT;",hints:["Use subqueries to get the other passenger's fare","Wrap in BEGIN/COMMIT"],points:25}}]},{id:4,title:"SQL for Data Analysis",subtitle:"Days 22-28",color:"from-green-500 to-teal-500",icon:"ðŸ“ˆ",days:[{day:22,title:"Date Functions",description:"Manipulate and extract information from dates",concepts:["date()","strftime()","Date Arithmetic"],lesson:{content:"# Date Functions ðŸ“…\n\n## Current Date/Time\n\n```sql\nSELECT date('now');           -- 2024-01-15\nSELECT datetime('now');       -- 2024-01-15 14:30:00\nSELECT time('now');           -- 14:30:00\n```\n\n## Date Formatting (strftime)\n\n```sql\nSELECT strftime('%Y', '2024-01-15');  -- 2024\nSELECT strftime('%m', '2024-01-15');  -- 01\nSELECT strftime('%d', '2024-01-15');  -- 15\nSELECT strftime('%W', '2024-01-15');  -- Week number\n```\n\n## Date Arithmetic\n\n```sql\nSELECT date('now', '+7 days');\nSELECT date('now', '-1 month');\nSELECT date('now', 'start of month');\n```\n\n## Age Calculation\n\n```sql\nSELECT \n  (strftime('%Y', 'now') - strftime('%Y', birth_date)) AS age\nFROM people;\n```",keyPoints:["date(), datetime(), time() get current values","strftime() formats and extracts date parts","Date modifiers allow arithmetic","Dates stored as TEXT in SQLite"]},challenge:{title:"Date Analysis",description:"Using the **ecommerce** dataset, find orders from the current year grouped by month. Show month and order count.",dataset:"ecommerce",solution:"SELECT strftime('%m', order_date) AS month, COUNT(*) AS order_count FROM orders WHERE strftime('%Y', order_date) = strftime('%Y', 'now') GROUP BY month ORDER BY month;",hints:["Use strftime('%Y',...) for year","Group by month"],points:25}},{day:23,title:"String Functions",description:"Manipulate and search text data",concepts:["UPPER","LOWER","SUBSTR","INSTR","REPLACE"],lesson:{content:"# String Functions ðŸ“\n\n## Case Conversion\n\n```sql\nSELECT UPPER(Name) FROM passengers;  -- JOHN SMITH\nSELECT LOWER(Name) FROM passengers;  -- john smith\n```\n\n## Substring\n\n```sql\nSELECT SUBSTR(Name, 1, 5) FROM passengers;  -- First 5 chars\nSELECT SUBSTR(Name, -3) FROM passengers;    -- Last 3 chars\n```\n\n## Finding Text\n\n```sql\nSELECT INSTR(Name, 'Mr.') FROM passengers;  -- Position or 0\nSELECT * FROM passengers WHERE Name LIKE '%Mr.%';\n```\n\n## Replacing Text\n\n```sql\nSELECT REPLACE(Name, 'Mr.', 'Mister') FROM passengers;\n```\n\n## Concatenation\n\n```sql\nSELECT Name || ' - Class ' || Pclass FROM passengers;\n```\n\n## Length and Trimming\n\n```sql\nSELECT LENGTH(Name) FROM passengers;\nSELECT TRIM('  hello  ');  -- 'hello'\n```",keyPoints:["|| concatenates strings in SQLite","SUBSTR extracts parts of strings","LIKE with % for pattern matching","TRIM removes whitespace"]},challenge:{title:"Name Parsing",description:"Extract the **title** (Mr., Mrs., Miss., etc.) from passenger names. Show the title and count of each.",dataset:"titanic",solution:"SELECT SUBSTR(Name, INSTR(Name, ', ') + 2, INSTR(SUBSTR(Name, INSTR(Name, ', ') + 2), '.')) AS title, COUNT(*) AS count FROM passengers GROUP BY title ORDER BY count DESC;",hints:["Titles are between ', ' and '.'","Use SUBSTR and INSTR"],points:30}},{day:24,title:"Math Functions",description:"Perform calculations and rounding in SQL",concepts:["ROUND","ABS","Mathematical Operations"],lesson:{content:"# Math Functions ðŸ”¢\n\n## Basic Math\n\n```sql\nSELECT 10 + 5;   -- 15\nSELECT 10 - 5;   -- 5\nSELECT 10 * 5;   -- 50\nSELECT 10 / 3;   -- 3 (integer division)\nSELECT 10.0 / 3; -- 3.333...\nSELECT 10 % 3;   -- 1 (modulo)\n```\n\n## Rounding\n\n```sql\nSELECT ROUND(3.14159, 2);  -- 3.14\nSELECT ROUND(Fare, 0) FROM passengers;\n```\n\n## Absolute Value\n\n```sql\nSELECT ABS(-42);  -- 42\n```\n\n## Calculations in Queries\n\n```sql\nSELECT Name, \n       Fare,\n       ROUND(Fare * 1.1, 2) AS fare_with_tax\nFROM passengers;\n```\n\n## Statistical Calculations\n\n```sql\nSELECT \n  AVG(Fare) AS mean,\n  MIN(Fare) AS minimum,\n  MAX(Fare) AS maximum,\n  MAX(Fare) - MIN(Fare) AS range\nFROM passengers;\n```",keyPoints:["Use 10.0 / 3 for decimal division","ROUND(value, decimals) rounds numbers","ABS returns absolute value","Combine with aggregates for statistics"]},challenge:{title:"Fare Analysis",description:"Calculate the **fare per family member** (SibSp + Parch + 1). Show Name, Fare, family_size, and fare_per_person (rounded to 2 decimals).",dataset:"titanic",solution:"SELECT Name, Fare, (SibSp + Parch + 1) AS family_size, ROUND(Fare / (SibSp + Parch + 1), 2) AS fare_per_person FROM passengers WHERE Fare > 0;",hints:["family_size = SibSp + Parch + 1","Use ROUND for fare_per_person"],points:20}},{day:25,title:"Window Functions",description:"Perform calculations across related rows",concepts:["OVER","PARTITION BY","ROW_NUMBER","RANK"],lesson:{content:"# Window Functions ðŸªŸ\n\n## What are Window Functions?\n\nCalculate values across a set of rows related to the current row.\n\n## ROW_NUMBER\n\n```sql\nSELECT Name, Fare,\n  ROW_NUMBER() OVER (ORDER BY Fare DESC) AS rank\nFROM passengers;\n```\n\n## PARTITION BY\n\n```sql\nSELECT Name, Pclass, Fare,\n  ROW_NUMBER() OVER (PARTITION BY Pclass ORDER BY Fare DESC) AS class_rank\nFROM passengers;\n```\n\n## Running Totals\n\n```sql\nSELECT Name, Fare,\n  SUM(Fare) OVER (ORDER BY PassengerId) AS running_total\nFROM passengers;\n```\n\n## RANK vs DENSE_RANK\n\n```sql\nSELECT Fare,\n  RANK() OVER (ORDER BY Fare DESC) AS rank,      -- 1,2,2,4\n  DENSE_RANK() OVER (ORDER BY Fare DESC) AS dense -- 1,2,2,3\nFROM passengers;\n```",keyPoints:["Window functions don't collapse rows like GROUP BY","OVER() defines the window","PARTITION BY creates sub-windows","ROW_NUMBER, RANK, DENSE_RANK for ordering"]},challenge:{title:"Ranking Passengers",description:"Rank passengers by fare **within their class**. Show Name, Pclass, Fare, and their rank (1 = highest fare).",dataset:"titanic",solution:"SELECT Name, Pclass, Fare, RANK() OVER (PARTITION BY Pclass ORDER BY Fare DESC) AS fare_rank FROM passengers;",hints:["PARTITION BY Pclass","ORDER BY Fare DESC in the window"],points:30}},{day:26,title:"Common Table Expressions (CTE)",description:"Write cleaner queries with WITH clause",concepts:["WITH","CTE","Recursive CTE"],lesson:{content:"# Common Table Expressions ðŸ“‹\n\n## Basic CTE\n\n```sql\nWITH survivors AS (\n  SELECT * FROM passengers WHERE Survived = 1\n)\nSELECT Pclass, COUNT(*) AS count\nFROM survivors\nGROUP BY Pclass;\n```\n\n## Multiple CTEs\n\n```sql\nWITH \n  survivors AS (\n    SELECT * FROM passengers WHERE Survived = 1\n  ),\n  class_stats AS (\n    SELECT Pclass, AVG(Fare) AS avg_fare\n    FROM survivors\n    GROUP BY Pclass\n  )\nSELECT * FROM class_stats;\n```\n\n## CTE vs Subquery\n\nCTEs are:\n- More readable\n- Reusable within the query\n- Self-documenting\n\n## Recursive CTE (Advanced)\n\n```sql\nWITH RECURSIVE countdown(n) AS (\n  SELECT 10\n  UNION ALL\n  SELECT n - 1 FROM countdown WHERE n > 1\n)\nSELECT n FROM countdown;\n```",keyPoints:["CTEs make complex queries readable","WITH clause defines temporary result sets","Multiple CTEs separated by commas","Recursive CTEs handle hierarchical data"]},challenge:{title:"CTE Analysis",description:"Use a CTE to find the **average fare by class**, then find passengers who paid more than their class average.",dataset:"titanic",solution:"WITH class_avg AS (SELECT Pclass, AVG(Fare) AS avg_fare FROM passengers GROUP BY Pclass) SELECT p.Name, p.Pclass, p.Fare, c.avg_fare FROM passengers p JOIN class_avg c ON p.Pclass = c.Pclass WHERE p.Fare > c.avg_fare;",hints:["First CTE calculates class averages","Main query joins and filters"],points:30}},{day:27,title:"Analytic Functions",description:"LAG, LEAD, and other analytic capabilities",concepts:["LAG","LEAD","FIRST_VALUE","LAST_VALUE"],lesson:{content:"# Analytic Functions ðŸ“Š\n\n## LAG - Previous Row Value\n\n```sql\nSELECT Name, Fare,\n  LAG(Fare) OVER (ORDER BY PassengerId) AS prev_fare\nFROM passengers;\n```\n\n## LEAD - Next Row Value\n\n```sql\nSELECT Name, Fare,\n  LEAD(Fare) OVER (ORDER BY PassengerId) AS next_fare\nFROM passengers;\n```\n\n## Calculating Differences\n\n```sql\nSELECT Name, Fare,\n  Fare - LAG(Fare) OVER (ORDER BY PassengerId) AS fare_diff\nFROM passengers;\n```\n\n## FIRST_VALUE / LAST_VALUE\n\n```sql\nSELECT Name, Pclass, Fare,\n  FIRST_VALUE(Name) OVER (\n    PARTITION BY Pclass \n    ORDER BY Fare DESC\n  ) AS highest_payer\nFROM passengers;\n```",keyPoints:["LAG accesses previous row values","LEAD accesses next row values","Useful for calculating changes/differences","FIRST_VALUE/LAST_VALUE get boundary values"]},challenge:{title:"Fare Comparison",description:"For each passenger, show their fare and the **difference from the previous passenger's fare** (ordered by PassengerId).",dataset:"titanic",solution:"SELECT Name, Fare, LAG(Fare) OVER (ORDER BY PassengerId) AS prev_fare, Fare - LAG(Fare) OVER (ORDER BY PassengerId) AS fare_difference FROM passengers;",hints:["Use LAG(Fare) OVER (ORDER BY PassengerId)","Subtract to get difference"],points:25}},{day:28,title:"Pivot & Unpivot",description:"Transform data between row and column formats",concepts:["CASE Pivot","Cross-Tabulation"],lesson:{content:"# Pivot Tables in SQL ðŸ”„\n\nSQLite doesn't have native PIVOT, but we can use CASE statements.\n\n## Pivot with CASE\n\nTurn rows into columns:\n\n```sql\nSELECT \n  Embarked,\n  SUM(CASE WHEN Pclass = 1 THEN 1 ELSE 0 END) AS first_class,\n  SUM(CASE WHEN Pclass = 2 THEN 1 ELSE 0 END) AS second_class,\n  SUM(CASE WHEN Pclass = 3 THEN 1 ELSE 0 END) AS third_class\nFROM passengers\nGROUP BY Embarked;\n```\n\n## Cross-Tabulation\n\n```sql\nSELECT \n  Sex,\n  SUM(CASE WHEN Survived = 1 THEN 1 ELSE 0 END) AS survived,\n  SUM(CASE WHEN Survived = 0 THEN 1 ELSE 0 END) AS died,\n  ROUND(AVG(Survived) * 100, 1) AS survival_rate\nFROM passengers\nGROUP BY Sex;\n```\n\n## Dynamic Aggregation\n\n```sql\nSELECT \n  Pclass,\n  COUNT(*) AS total,\n  SUM(Survived) AS survivors,\n  ROUND(100.0 * SUM(Survived) / COUNT(*), 1) AS pct\nFROM passengers\nGROUP BY Pclass;\n```",keyPoints:["Use CASE inside aggregates for pivot","GROUP BY determines your rows","CASE WHEN determines your columns","Great for cross-tabulation reports"]},challenge:{title:"Survival Pivot",description:"Create a pivot showing **survival count by Sex and Class**. Rows = Sex, Columns = Class (1, 2, 3).",dataset:"titanic",solution:"SELECT Sex, SUM(CASE WHEN Pclass = 1 AND Survived = 1 THEN 1 ELSE 0 END) AS class1_survived, SUM(CASE WHEN Pclass = 2 AND Survived = 1 THEN 1 ELSE 0 END) AS class2_survived, SUM(CASE WHEN Pclass = 3 AND Survived = 1 THEN 1 ELSE 0 END) AS class3_survived FROM passengers GROUP BY Sex;",hints:["GROUP BY Sex for rows","CASE for each class column"],points:30}}]},{id:5,title:"SQL Best Practices & Optimization",subtitle:"Days 29-30",color:"from-yellow-500 to-amber-500",icon:"âš¡",days:[{day:29,title:"Index Optimization",description:"Advanced indexing strategies for query performance",concepts:["Query Plans","Index Selection","Covering Indexes"],lesson:{content:"# Index Optimization âš¡\n\n## Query Execution Plan\n\n```sql\nEXPLAIN QUERY PLAN\nSELECT * FROM passengers WHERE Pclass = 1;\n```\n\nShows how SQLite will execute your query.\n\n## Index Types\n\n1. **Single Column**: One column\n2. **Composite**: Multiple columns (order matters!)\n3. **Covering**: Contains all needed columns\n\n## Composite Index Order\n\n```sql\nCREATE INDEX idx_class_survived \nON passengers(Pclass, Survived);\n\n-- Uses index well:\nWHERE Pclass = 1 AND Survived = 1\nWHERE Pclass = 1\n\n-- May not use index:\nWHERE Survived = 1  -- Second column only!\n```\n\n## When NOT to Index\n\n- Columns with few unique values\n- Frequently updated columns\n- Small tables (< 1000 rows)\n- Columns rarely in WHERE/JOIN",keyPoints:["EXPLAIN QUERY PLAN shows execution","Composite index column order matters","Covering indexes include all SELECT columns","Too many indexes slow writes"]},challenge:{title:"Optimize Query",description:"Use EXPLAIN QUERY PLAN to analyze a query, then create an appropriate index to optimize it.",dataset:"titanic",solution:"EXPLAIN QUERY PLAN SELECT Name, Fare FROM passengers WHERE Pclass = 1 AND Survived = 1 ORDER BY Fare DESC; CREATE INDEX idx_class_surv_fare ON passengers(Pclass, Survived, Fare);",hints:["First EXPLAIN the query","Index columns used in WHERE and ORDER BY"],points:30}},{day:30,title:"Query Performance Tuning",description:"Write efficient queries and avoid common pitfalls",concepts:["Query Optimization","Best Practices","Common Mistakes"],lesson:{content:"# Query Performance Tuning ðŸŽ¯\n\n## DO: Select Only What You Need\n\n```sql\n-- âŒ Bad\nSELECT * FROM passengers;\n\n-- âœ… Good\nSELECT Name, Age FROM passengers;\n```\n\n## DO: Use WHERE to Limit Data Early\n\n```sql\n-- âŒ Bad (filters after aggregation)\nSELECT * FROM (\n  SELECT Pclass, AVG(Fare) FROM passengers GROUP BY Pclass\n) WHERE Pclass = 1;\n\n-- âœ… Good (filters before aggregation)\nSELECT Pclass, AVG(Fare) FROM passengers \nWHERE Pclass = 1 GROUP BY Pclass;\n```\n\n## DON'T: Use Functions on Indexed Columns\n\n```sql\n-- âŒ Can't use index\nWHERE UPPER(Name) = 'JOHN'\n\n-- âœ… Can use index\nWHERE Name = 'John'\n```\n\n## DO: Use EXISTS Instead of IN for Large Subqueries\n\n```sql\n-- Often faster:\nWHERE EXISTS (SELECT 1 FROM other WHERE other.id = main.id)\n```\n\n## Final Tips\n\n1. Index columns in WHERE, JOIN, ORDER BY\n2. Avoid SELECT *\n3. Use LIMIT for testing\n4. Profile with EXPLAIN QUERY PLAN",keyPoints:["Select only needed columns","Filter early with WHERE","Avoid functions on indexed columns","Use EXPLAIN to find bottlenecks"]},challenge:{title:"Graduation Challenge",description:"Write an optimized query to find the **top 5 highest-paying survivors in each class** with their class rank. Use CTEs and window functions.",dataset:"titanic",solution:"WITH ranked_survivors AS (SELECT Name, Pclass, Fare, RANK() OVER (PARTITION BY Pclass ORDER BY Fare DESC) AS class_rank FROM passengers WHERE Survived = 1) SELECT * FROM ranked_survivors WHERE class_rank <= 5 ORDER BY Pclass, class_rank;",hints:["CTE with window function for ranking","Filter to top 5 per class"],points:50}}]}]},window.weeklyRewards={1:{xp:100,badge:"SQL Foundations",icon:"ðŸ…"},2:{xp:150,badge:"Query Architect",icon:"ðŸ¥ˆ"},3:{xp:200,badge:"Database Expert",icon:"ðŸ¥‡"},4:{xp:250,badge:"Data Analyst",icon:"ðŸ†"},5:{xp:300,badge:"SQL Master",icon:"ðŸ‘‘"}},window.masterReward={xp:1e3,badge:"30-Day SQL Master",icon:"ðŸŽ“",title:"SQL Master"};