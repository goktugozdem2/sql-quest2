window.thirtyDayChallenge={title:"Master SQL 30-Day Challenge",description:"Transform from SQL beginner to expert in 30 days with our structured curriculum",weeks:[{id:1,title:"SQL for Data Analysis",subtitle:"Days 1-7: Fundamentals",color:"from-blue-500 to-cyan-500",icon:"ðŸ“Š"},{id:2,title:"Intermediate SQL",subtitle:"Days 8-14: Level Up",color:"from-green-500 to-emerald-500",icon:"ðŸ“ˆ"},{id:3,title:"Advanced SQL",subtitle:"Days 15-21: Pro Skills",color:"from-purple-500 to-pink-500",icon:"ðŸš€"},{id:4,title:"SQL for Data Analysis",subtitle:"Days 22-28: Analytics",color:"from-orange-500 to-red-500",icon:"ðŸ”¬"},{id:5,title:"Best Practices",subtitle:"Days 29-30: Mastery",color:"from-yellow-500 to-amber-500",icon:"ðŸ†"}],days:[{day:1,week:1,title:"Introduction to SQL",description:"Learn what SQL is, why it matters, and write your first query",concepts:["SQL basics","Databases","Tables"],lesson:{content:"# Welcome to SQL! ðŸŽ‰\n\n**SQL (Structured Query Language)** is the standard language for working with databases. It's used by data analysts, scientists, engineers, and developers worldwide.\n\n## What You'll Learn Today\n- What SQL is and why it's important\n- How databases organize data\n- Your first SELECT query\n\n## Key Concepts\n\n### Databases & Tables\nA **database** is like a filing cabinet that stores organized data. Inside, **tables** hold the actual data in rows and columns - just like a spreadsheet!\n\n### The SELECT Statement\nThe most fundamental SQL command retrieves data from a table:\n\n```sql\nSELECT * FROM employees;\n```\n\nThis gets ALL columns (*) from the employees table.\n\n### Selecting Specific Columns\n```sql\nSELECT name, salary FROM employees;\n```\n\nThis gets only the name and salary columns.",tips:["SQL keywords like SELECT and FROM are not case-sensitive, but UPPERCASE is conventional","Always end statements with a semicolon (;)","The * symbol means 'all columns'"]},challenge:{title:"Your First Query",description:"Write a query to select all columns from the **passengers** table in the Titanic dataset.",dataset:"titanic",solution:"SELECT * FROM passengers;",alternativeSolutions:["SELECT * FROM passengers","select * from passengers;"],hints:["Use SELECT * to get all columns","The table name is 'passengers'","Don't forget the semicolon!"],expectedRows:891,points:10},bonusChallenge:{title:"Specific Columns",description:"Select only the **Name** and **Age** columns from the passengers table.",solution:"SELECT Name, Age FROM passengers;",points:5}},{day:2,week:1,title:"Understanding Databases and Tables",description:"Explore database structure, data types, and table schemas",concepts:["Schema","Data types","Table structure"],lesson:{content:"# Databases & Tables Deep Dive ðŸ—„ï¸\n\n## Database Structure\n\nThink of a database as a container that holds multiple related tables:\n\n```\nDatabase: company_db\nâ”œâ”€â”€ employees (table)\nâ”œâ”€â”€ departments (table)\nâ”œâ”€â”€ salaries (table)\nâ””â”€â”€ projects (table)\n```\n\n## Data Types\n\nEach column has a specific data type:\n\n| Type | Description | Example |\n|------|-------------|---------|\n| INTEGER | Whole numbers | 42, -7, 0 |\n| REAL/FLOAT | Decimal numbers | 3.14, -0.5 |\n| TEXT | Strings/words | 'Hello', 'John' |\n| DATE | Dates | '2024-01-15' |\n| BOOLEAN | True/False | 1, 0 |\n\n## Viewing Table Structure\n\nTo see what columns a table has:\n```sql\nPRAGMA table_info(passengers);\n```\n\n## NULL Values\nNULL represents missing or unknown data - it's different from 0 or empty string!",tips:["NULL is not the same as 0 or an empty string","Data types help ensure data integrity","Understanding schema is crucial for writing correct queries"]},challenge:{title:"Explore the Schema",description:"Select the **PassengerId**, **Name**, **Sex**, and **Age** columns from the passengers table.",dataset:"titanic",solution:"SELECT PassengerId, Name, Sex, Age FROM passengers;",hints:["List column names separated by commas","Column names are case-sensitive"],points:10}},{day:3,week:1,title:"SELECT Statement Mastery",description:"Master column selection, aliases, and expressions",concepts:["SELECT","Aliases","Expressions"],lesson:{content:"# SELECT Statement Mastery ðŸŽ¯\n\n## Column Aliases\nGive columns friendlier names using AS:\n\n```sql\nSELECT Name AS passenger_name, \n       Age AS passenger_age \nFROM passengers;\n```\n\n## Expressions in SELECT\nPerform calculations directly in your query:\n\n```sql\nSELECT Name, \n       Age,\n       Age * 12 AS age_in_months\nFROM passengers;\n```\n\n## String Concatenation\nCombine text values:\n\n```sql\nSELECT Name || ' - ' || Sex AS passenger_info\nFROM passengers;\n```\n\n## DISTINCT - Remove Duplicates\nGet unique values only:\n\n```sql\nSELECT DISTINCT Pclass FROM passengers;\n```\n\nThis returns only the unique passenger classes (1, 2, 3).",tips:["AS keyword is optional but improves readability","Use || for string concatenation in SQLite","DISTINCT is great for exploring unique values in a column"]},challenge:{title:"Calculated Columns",description:"Select passenger **Name**, **Fare**, and create a column called **fare_in_cents** that multiplies Fare by 100.",dataset:"titanic",solution:"SELECT Name, Fare, Fare * 100 AS fare_in_cents FROM passengers;",hints:["Use AS to create an alias","Multiply Fare by 100","Column alias should be fare_in_cents"],points:15}},{day:4,week:1,title:"WHERE Clause and Logical Operators",description:"Filter data using conditions and combine them with AND/OR",concepts:["WHERE","AND","OR","Comparison operators"],lesson:{content:"# Filtering with WHERE ðŸ”\n\n## Basic WHERE Clause\nFilter rows that match a condition:\n\n```sql\nSELECT * FROM passengers\nWHERE Age > 30;\n```\n\n## Comparison Operators\n\n| Operator | Meaning |\n|----------|---------|\n| = | Equal to |\n| != or <> | Not equal to |\n| > | Greater than |\n| < | Less than |\n| >= | Greater than or equal |\n| <= | Less than or equal |\n\n## Combining Conditions\n\n### AND - Both must be true\n```sql\nSELECT * FROM passengers\nWHERE Age > 30 AND Sex = 'female';\n```\n\n### OR - Either can be true\n```sql\nSELECT * FROM passengers\nWHERE Pclass = 1 OR Pclass = 2;\n```\n\n### NOT - Negate a condition\n```sql\nSELECT * FROM passengers\nWHERE NOT Survived = 0;\n```\n\n## Working with NULL\n```sql\nSELECT * FROM passengers WHERE Age IS NULL;\nSELECT * FROM passengers WHERE Age IS NOT NULL;\n```",tips:["Text values need single quotes: 'female'","Use IS NULL, not = NULL for null checks","Parentheses help clarify complex conditions"]},challenge:{title:"Filter Survivors",description:"Find all **female passengers** who **survived** (Survived = 1).",dataset:"titanic",solution:"SELECT * FROM passengers WHERE Sex = 'female' AND Survived = 1;",hints:["Use AND to combine conditions","Sex should equal 'female' (with quotes)","Survived should equal 1"],points:15}},{day:5,week:1,title:"Sorting Data with ORDER BY",description:"Sort results in ascending or descending order",concepts:["ORDER BY","ASC","DESC","Multiple sorting"],lesson:{content:"# Sorting with ORDER BY ðŸ“Š\n\n## Basic Sorting\nSort results by a column:\n\n```sql\nSELECT * FROM passengers\nORDER BY Age;\n```\n\n## Ascending vs Descending\n\n```sql\n-- Youngest first (default)\nSELECT * FROM passengers ORDER BY Age ASC;\n\n-- Oldest first\nSELECT * FROM passengers ORDER BY Age DESC;\n```\n\n## Multiple Sort Columns\nSort by multiple columns - first by Pclass, then by Age within each class:\n\n```sql\nSELECT * FROM passengers\nORDER BY Pclass ASC, Age DESC;\n```\n\n## Sorting with NULL\nNULL values appear first with ASC, last with DESC (in most databases).\n\n## Combining with WHERE\n```sql\nSELECT Name, Age, Fare FROM passengers\nWHERE Survived = 1\nORDER BY Fare DESC;\n```",tips:["ASC is the default (ascending)","DESC sorts from highest to lowest","ORDER BY always comes after WHERE"]},challenge:{title:"Top Fares",description:"Find the **top 20 passengers** who paid the highest **Fare**. Show Name, Pclass, and Fare, sorted by Fare descending.",dataset:"titanic",solution:"SELECT Name, Pclass, Fare FROM passengers ORDER BY Fare DESC LIMIT 20;",hints:["Use ORDER BY Fare DESC for highest first","Add LIMIT 20 at the end","Select only the requested columns"],points:15}},{day:6,week:1,title:"LIMIT & OFFSET",description:"Control how many rows to return and pagination",concepts:["LIMIT","OFFSET","Pagination"],lesson:{content:'# LIMIT & OFFSET ðŸ“„\n\n## LIMIT - Restrict Results\nGet only a specific number of rows:\n\n```sql\nSELECT * FROM passengers LIMIT 10;\n```\n\n## OFFSET - Skip Rows\nSkip the first N rows:\n\n```sql\nSELECT * FROM passengers LIMIT 10 OFFSET 20;\n```\nThis skips 20 rows, then returns the next 10.\n\n## Pagination Example\nFor a "page" system with 10 items per page:\n\n```sql\n-- Page 1 (rows 1-10)\nSELECT * FROM passengers LIMIT 10 OFFSET 0;\n\n-- Page 2 (rows 11-20)\nSELECT * FROM passengers LIMIT 10 OFFSET 10;\n\n-- Page 3 (rows 21-30)\nSELECT * FROM passengers LIMIT 10 OFFSET 20;\n```\n\n## Practical Use Cases\n- Preview large datasets\n- Build paginated APIs\n- Get "Top N" results with ORDER BY',tips:["LIMIT without OFFSET returns from the beginning","OFFSET formula: (page_number - 1) * items_per_page","Always use ORDER BY with LIMIT for consistent results"]},challenge:{title:"Pagination Practice",description:"Get the **second page** of passengers (rows 11-20) sorted by **PassengerId**. Show 10 results.",dataset:"titanic",solution:"SELECT * FROM passengers ORDER BY PassengerId LIMIT 10 OFFSET 10;",hints:["Page 2 needs OFFSET 10 (skip first 10)","LIMIT 10 for 10 results per page","ORDER BY ensures consistent pagination"],points:15}},{day:7,week:1,title:"Aggregate Functions",description:"Calculate totals, averages, counts, and more",concepts:["COUNT","SUM","AVG","MIN","MAX"],lesson:{content:"# Aggregate Functions ðŸ“ˆ\n\nAggregate functions perform calculations across multiple rows.\n\n## COUNT - Count Rows\n```sql\n-- Count all rows\nSELECT COUNT(*) FROM passengers;\n\n-- Count non-null values in a column\nSELECT COUNT(Age) FROM passengers;\n```\n\n## SUM - Total Values\n```sql\nSELECT SUM(Fare) AS total_revenue FROM passengers;\n```\n\n## AVG - Average Value\n```sql\nSELECT AVG(Age) AS average_age FROM passengers;\n```\n\n## MIN & MAX\n```sql\nSELECT MIN(Age) AS youngest,\n       MAX(Age) AS oldest\nFROM passengers;\n```\n\n## Combining Aggregates\n```sql\nSELECT \n    COUNT(*) AS total_passengers,\n    SUM(Survived) AS survivors,\n    AVG(Fare) AS avg_fare,\n    MIN(Age) AS youngest,\n    MAX(Age) AS oldest\nFROM passengers;\n```\n\n## With WHERE\n```sql\nSELECT AVG(Age) FROM passengers WHERE Survived = 1;\n```",tips:["COUNT(*) counts all rows, COUNT(column) skips NULLs","AVG ignores NULL values","Use aliases to make results readable"]},challenge:{title:"Survival Statistics",description:"Calculate the **total passengers**, **number who survived** (SUM of Survived), and **survival rate** (AVG of Survived * 100).",dataset:"titanic",solution:"SELECT COUNT(*) AS total_passengers, SUM(Survived) AS survivors, AVG(Survived) * 100 AS survival_rate FROM passengers;",hints:["COUNT(*) for total passengers","SUM(Survived) since Survived is 0 or 1","AVG(Survived) * 100 gives percentage"],points:20}},{day:8,week:2,title:"GROUP BY Clause",description:"Group rows and calculate aggregates per group",concepts:["GROUP BY","Aggregates per group"],lesson:{content:"# GROUP BY - Grouping Data ðŸ“Š\n\nGROUP BY lets you calculate aggregates for each group separately.\n\n## Basic GROUP BY\n```sql\nSELECT Pclass, COUNT(*) AS passengers\nFROM passengers\nGROUP BY Pclass;\n```\n\nResult:\n| Pclass | passengers |\n|--------|------------|\n| 1 | 216 |\n| 2 | 184 |\n| 3 | 491 |\n\n## Multiple Aggregates per Group\n```sql\nSELECT Pclass,\n       COUNT(*) AS total,\n       SUM(Survived) AS survived,\n       AVG(Fare) AS avg_fare\nFROM passengers\nGROUP BY Pclass;\n```\n\n## GROUP BY Multiple Columns\n```sql\nSELECT Pclass, Sex, COUNT(*) AS count\nFROM passengers\nGROUP BY Pclass, Sex;\n```\n\n## Important Rule\nEvery column in SELECT must either be:\n1. In the GROUP BY clause, OR\n2. Inside an aggregate function",tips:["GROUP BY creates 'buckets' of rows","Each group returns exactly one row in results","Column order in GROUP BY can affect results"]},challenge:{title:"Survival by Class",description:"Calculate the **survival rate** (AVG of Survived * 100) for each **passenger class** (Pclass). Order by class.",dataset:"titanic",solution:"SELECT Pclass, AVG(Survived) * 100 AS survival_rate FROM passengers GROUP BY Pclass ORDER BY Pclass;",hints:["GROUP BY Pclass","AVG(Survived) * 100 for percentage","ORDER BY Pclass at the end"],points:20}},{day:9,week:2,title:"HAVING Clause",description:"Filter groups after aggregation",concepts:["HAVING","WHERE vs HAVING"],lesson:{content:"# HAVING - Filter Groups ðŸ”\n\nHAVING filters groups AFTER aggregation (WHERE filters rows BEFORE).\n\n## WHERE vs HAVING\n\n```sql\n-- WHERE: Filter rows before grouping\nSELECT Pclass, COUNT(*) \nFROM passengers\nWHERE Age > 30\nGROUP BY Pclass;\n\n-- HAVING: Filter groups after aggregation\nSELECT Pclass, COUNT(*) AS count\nFROM passengers\nGROUP BY Pclass\nHAVING COUNT(*) > 100;\n```\n\n## Using Both Together\n```sql\nSELECT Embarked, COUNT(*) AS passengers\nFROM passengers\nWHERE Survived = 1          -- Filter rows first\nGROUP BY Embarked\nHAVING COUNT(*) > 50;       -- Then filter groups\n```\n\n## HAVING with Aggregates\n```sql\nSELECT Pclass, AVG(Fare) AS avg_fare\nFROM passengers\nGROUP BY Pclass\nHAVING AVG(Fare) > 50;\n```\n\n## Order of Execution\n1. FROM â†’ 2. WHERE â†’ 3. GROUP BY â†’ 4. HAVING â†’ 5. SELECT â†’ 6. ORDER BY",tips:["HAVING requires GROUP BY","Use WHERE for row-level filters","Use HAVING for aggregate-level filters"]},challenge:{title:"Popular Embarkation Points",description:"Find embarkation points (**Embarked**) with more than **200 passengers**. Show the port and count.",dataset:"titanic",solution:"SELECT Embarked, COUNT(*) AS passenger_count FROM passengers GROUP BY Embarked HAVING COUNT(*) > 200;",hints:["GROUP BY Embarked","Use HAVING COUNT(*) > 200","Not WHERE - we're filtering on aggregate"],points:20}},{day:10,week:2,title:"JOINs - INNER, LEFT, RIGHT",description:"Combine data from multiple tables",concepts:["INNER JOIN","LEFT JOIN","RIGHT JOIN"],lesson:{content:"# JOINs - Combining Tables ðŸ”—\n\nJOINs let you combine rows from two or more tables based on related columns.\n\n## INNER JOIN\nReturns only matching rows from both tables:\n\n```sql\nSELECT e.name, d.department_name\nFROM employees e\nINNER JOIN departments d ON e.dept_id = d.id;\n```\n\n## LEFT JOIN\nReturns all rows from left table, with matches from right (NULL if no match):\n\n```sql\nSELECT e.name, d.department_name\nFROM employees e\nLEFT JOIN departments d ON e.dept_id = d.id;\n```\n\n## RIGHT JOIN\nReturns all rows from right table, with matches from left:\n\n```sql\nSELECT e.name, d.department_name\nFROM employees e\nRIGHT JOIN departments d ON e.dept_id = d.id;\n```\n\n## Visual Representation\n```\nINNER: Only intersection\nLEFT:  All left + matching right\nRIGHT: All right + matching left\n```",tips:["Use table aliases (e, d) for cleaner queries","INNER JOIN is the most common type","LEFT JOIN is great for finding 'missing' relationships"]},challenge:{title:"Join Practice",description:"Using the **ecommerce** dataset, join **orders** with **customers** to show customer **name** and their **order_total**. Use INNER JOIN.",dataset:"ecommerce",solution:"SELECT c.name, o.order_total FROM orders o INNER JOIN customers c ON o.customer_id = c.id;",hints:["Join ON orders.customer_id = customers.id","Use table aliases for cleaner code","Select name from customers, order_total from orders"],points:25}},{day:11,week:2,title:"Subqueries",description:"Nest queries inside other queries",concepts:["Subqueries","IN","EXISTS"],lesson:{content:"# Subqueries - Queries within Queries ðŸŽ­\n\nA subquery is a query nested inside another query.\n\n## Subquery in WHERE\n```sql\nSELECT * FROM passengers\nWHERE Fare > (SELECT AVG(Fare) FROM passengers);\n```\n\n## Subquery with IN\n```sql\nSELECT * FROM passengers\nWHERE Pclass IN (SELECT Pclass FROM passengers WHERE Survived = 1);\n```\n\n## Subquery in FROM (Derived Table)\n```sql\nSELECT avg_by_class.Pclass, avg_by_class.avg_fare\nFROM (\n    SELECT Pclass, AVG(Fare) AS avg_fare\n    FROM passengers\n    GROUP BY Pclass\n) AS avg_by_class\nWHERE avg_by_class.avg_fare > 30;\n```\n\n## Correlated Subquery\nReferences the outer query:\n```sql\nSELECT p1.Name, p1.Fare\nFROM passengers p1\nWHERE p1.Fare > (\n    SELECT AVG(p2.Fare)\n    FROM passengers p2\n    WHERE p2.Pclass = p1.Pclass\n);\n```",tips:["Subqueries must be enclosed in parentheses","Use aliases for derived tables","Correlated subqueries run once per outer row"]},challenge:{title:"Above Average Fares",description:"Find all passengers who paid **more than the average fare**. Show Name, Fare, and Pclass.",dataset:"titanic",solution:"SELECT Name, Fare, Pclass FROM passengers WHERE Fare > (SELECT AVG(Fare) FROM passengers);",hints:["Use a subquery to calculate AVG(Fare)","Compare each row's Fare to this average","The subquery goes in the WHERE clause"],points:25}},{day:12,week:2,title:"CASE Statements",description:"Add conditional logic to your queries",concepts:["CASE WHEN","Conditional logic"],lesson:{content:"# CASE - Conditional Logic ðŸ”€\n\nCASE adds if-then-else logic to SQL queries.\n\n## Simple CASE\n```sql\nSELECT Name,\n       CASE Pclass\n           WHEN 1 THEN 'First Class'\n           WHEN 2 THEN 'Second Class'\n           WHEN 3 THEN 'Third Class'\n       END AS class_name\nFROM passengers;\n```\n\n## Searched CASE (with conditions)\n```sql\nSELECT Name, Age,\n       CASE\n           WHEN Age < 18 THEN 'Minor'\n           WHEN Age < 65 THEN 'Adult'\n           ELSE 'Senior'\n       END AS age_group\nFROM passengers;\n```\n\n## CASE in Aggregations\n```sql\nSELECT \n    SUM(CASE WHEN Survived = 1 THEN 1 ELSE 0 END) AS survivors,\n    SUM(CASE WHEN Survived = 0 THEN 1 ELSE 0 END) AS casualties\nFROM passengers;\n```\n\n## CASE for Pivoting\n```sql\nSELECT Pclass,\n    SUM(CASE WHEN Sex = 'male' THEN 1 ELSE 0 END) AS males,\n    SUM(CASE WHEN Sex = 'female' THEN 1 ELSE 0 END) AS females\nFROM passengers\nGROUP BY Pclass;\n```",tips:["Always include END to close CASE","ELSE is optional but recommended","CASE can be used in SELECT, WHERE, ORDER BY"]},challenge:{title:"Age Categories",description:"Create age categories: 'Child' (Age < 18), 'Adult' (18-59), 'Senior' (60+). Count passengers in each category.",dataset:"titanic",solution:"SELECT CASE WHEN Age < 18 THEN 'Child' WHEN Age < 60 THEN 'Adult' ELSE 'Senior' END AS age_group, COUNT(*) AS count FROM passengers WHERE Age IS NOT NULL GROUP BY age_group;",hints:["Use CASE WHEN for conditions","GROUP BY the CASE expression","Filter out NULL ages with WHERE"],points:25}},{day:13,week:2,title:"Self-Joins",description:"Join a table to itself",concepts:["Self-Join","Table aliases"],lesson:{content:"# Self-Joins ðŸ”„\n\nA self-join joins a table to itself - useful for hierarchical or comparative data.\n\n## Employee-Manager Example\n```sql\nSELECT e.name AS employee,\n       m.name AS manager\nFROM employees e\nLEFT JOIN employees m ON e.manager_id = m.id;\n```\n\n## Finding Pairs\nFind passengers with the same fare:\n```sql\nSELECT p1.Name AS passenger1,\n       p2.Name AS passenger2,\n       p1.Fare\nFROM passengers p1\nJOIN passengers p2 ON p1.Fare = p2.Fare\nWHERE p1.PassengerId < p2.PassengerId;\n```\n\n## Comparing Rows\nFind passengers older than average of their class:\n```sql\nSELECT p1.Name, p1.Age, p1.Pclass\nFROM passengers p1\nJOIN (\n    SELECT Pclass, AVG(Age) as avg_age\n    FROM passengers\n    GROUP BY Pclass\n) p2 ON p1.Pclass = p2.Pclass\nWHERE p1.Age > p2.avg_age;\n```",tips:["Always use different aliases for each 'copy' of the table","Use inequality (< or >) to avoid duplicate pairs","Self-joins are powerful for hierarchical data"]},challenge:{title:"Fare Twins",description:"Find pairs of passengers with the **exact same Fare**. Show both names and the fare. Avoid duplicates (passenger1 ID < passenger2 ID).",dataset:"titanic",solution:"SELECT p1.Name AS passenger1, p2.Name AS passenger2, p1.Fare FROM passengers p1 JOIN passengers p2 ON p1.Fare = p2.Fare AND p1.PassengerId < p2.PassengerId WHERE p1.Fare > 0;",hints:["Join passengers to itself","Match on Fare equality","Use PassengerId < to avoid duplicates"],points:25}},{day:14,week:2,title:"UNION & UNION ALL",description:"Combine results from multiple queries",concepts:["UNION","UNION ALL","Set operations"],lesson:{content:"# UNION - Combining Results ðŸ“‹\n\nUNION combines the results of two or more SELECT statements.\n\n## UNION (removes duplicates)\n```sql\nSELECT Name FROM passengers WHERE Pclass = 1\nUNION\nSELECT Name FROM passengers WHERE Survived = 1;\n```\n\n## UNION ALL (keeps duplicates)\n```sql\nSELECT Name FROM passengers WHERE Pclass = 1\nUNION ALL\nSELECT Name FROM passengers WHERE Survived = 1;\n```\n\n## Rules for UNION\n1. Same number of columns in each SELECT\n2. Compatible data types\n3. Column names come from first SELECT\n\n## Practical Example\n```sql\nSELECT 'Survivor' AS status, Name, Age\nFROM passengers WHERE Survived = 1\nUNION ALL\nSELECT 'Casualty' AS status, Name, Age\nFROM passengers WHERE Survived = 0;\n```\n\n## Other Set Operations\n- INTERSECT: Only rows in both results\n- EXCEPT: Rows in first but not second",tips:["UNION is slower than UNION ALL (checks for duplicates)","Use UNION ALL when you know there are no duplicates","ORDER BY applies to the final combined result"]},challenge:{title:"Combined Lists",description:"Create a list showing all passengers from **first class** OR who **paid more than $100**. Use UNION to combine and remove duplicates. Show Name and Fare.",dataset:"titanic",solution:"SELECT Name, Fare FROM passengers WHERE Pclass = 1 UNION SELECT Name, Fare FROM passengers WHERE Fare > 100;",hints:["First SELECT: WHERE Pclass = 1","Second SELECT: WHERE Fare > 100","UNION removes duplicates automatically"],points:20}},{day:15,week:3,title:"Understanding Indexes",description:"Learn how indexes speed up queries",concepts:["Indexes","Performance","CREATE INDEX"],lesson:{content:"# Indexes - Speed Up Your Queries âš¡\n\n## What is an Index?\nAn index is like a book's index - it helps find data without scanning every row.\n\n## Creating an Index\n```sql\nCREATE INDEX idx_passengers_age ON passengers(Age);\n```\n\n## Composite Index (multiple columns)\n```sql\nCREATE INDEX idx_class_survived ON passengers(Pclass, Survived);\n```\n\n## When Indexes Help\n- WHERE clause filters\n- JOIN conditions\n- ORDER BY columns\n- GROUP BY columns\n\n## When Indexes Don't Help\n- Small tables\n- Columns with few unique values\n- Queries returning most rows\n\n## Trade-offs\nâœ… Faster reads\nâŒ Slower writes (INSERT, UPDATE, DELETE)\nâŒ Uses storage space",tips:["Index columns you frequently filter or sort by","Don't over-index - each index has overhead","Composite indexes work left-to-right"]},challenge:{title:"Index Analysis",description:"Which columns would benefit most from an index in a query that filters by **Pclass** and sorts by **Fare**? Write a query using these columns.",dataset:"titanic",solution:"SELECT Name, Pclass, Fare FROM passengers WHERE Pclass = 1 ORDER BY Fare DESC;",hints:["Pclass in WHERE would benefit from index","Fare in ORDER BY would also benefit","A composite index (Pclass, Fare) would be ideal"],points:20}},{day:16,week:3,title:"Working with Views",description:"Create virtual tables for reusable queries",concepts:["CREATE VIEW","Virtual tables","Abstraction"],lesson:{content:"# Views - Reusable Query Shortcuts ðŸ‘ï¸\n\nA view is a saved query that acts like a virtual table.\n\n## Creating a View\n```sql\nCREATE VIEW survivors AS\nSELECT * FROM passengers WHERE Survived = 1;\n```\n\n## Using a View\n```sql\nSELECT * FROM survivors WHERE Pclass = 1;\n```\n\n## Complex View Example\n```sql\nCREATE VIEW passenger_summary AS\nSELECT \n    Pclass,\n    Sex,\n    COUNT(*) AS total,\n    SUM(Survived) AS survived,\n    ROUND(AVG(Survived) * 100, 1) AS survival_rate\nFROM passengers\nGROUP BY Pclass, Sex;\n```\n\n## Benefits of Views\n- Simplify complex queries\n- Provide data abstraction\n- Security (hide sensitive columns)\n- Consistent calculations\n\n## Dropping a View\n```sql\nDROP VIEW IF EXISTS survivors;\n```",tips:["Views don't store data - they run the query each time","Views can join multiple tables","Use views to simplify reporting queries"]},challenge:{title:"Create a Summary View",description:"Create a query that could be a view: Show **survival stats by class and gender** (Pclass, Sex, total, survived, survival_rate).",dataset:"titanic",solution:"SELECT Pclass, Sex, COUNT(*) AS total, SUM(Survived) AS survived, ROUND(AVG(Survived) * 100, 1) AS survival_rate FROM passengers GROUP BY Pclass, Sex ORDER BY Pclass, Sex;",hints:["GROUP BY Pclass, Sex","COUNT(*) for total","AVG(Survived) * 100 for percentage"],points:25}},{day:17,week:3,title:"Transaction Management",description:"Ensure data integrity with transactions",concepts:["BEGIN","COMMIT","ROLLBACK","ACID"],lesson:{content:"# Transactions - All or Nothing ðŸ”\n\nTransactions group multiple operations into a single unit that either completely succeeds or completely fails.\n\n## Basic Transaction\n```sql\nBEGIN TRANSACTION;\n    UPDATE accounts SET balance = balance - 100 WHERE id = 1;\n    UPDATE accounts SET balance = balance + 100 WHERE id = 2;\nCOMMIT;\n```\n\n## Rollback on Error\n```sql\nBEGIN TRANSACTION;\n    UPDATE accounts SET balance = balance - 100 WHERE id = 1;\n    -- If something goes wrong:\nROLLBACK;\n```\n\n## ACID Properties\n- **A**tomicity: All or nothing\n- **C**onsistency: Data stays valid\n- **I**solation: Transactions don't interfere\n- **D**urability: Committed changes persist\n\n## Savepoints\n```sql\nBEGIN TRANSACTION;\n    UPDATE table1 SET col1 = 'value1';\n    SAVEPOINT sp1;\n    UPDATE table2 SET col2 = 'value2';\n    -- Oops, rollback just the second update\n    ROLLBACK TO sp1;\nCOMMIT;\n```",tips:["Always COMMIT or ROLLBACK to end a transaction","Use transactions for multi-step operations","Transactions prevent partial updates"]},challenge:{title:"Transaction Concepts",description:"Write a query that shows the total fare collected by class, simulating a 'report' that might be part of a transaction.",dataset:"titanic",solution:"SELECT Pclass, SUM(Fare) AS total_fare, COUNT(*) AS passengers FROM passengers GROUP BY Pclass ORDER BY Pclass;",hints:["GROUP BY Pclass","SUM(Fare) for total fare","This type of aggregation might be in a reporting transaction"],points:20}},{day:18,week:3,title:"Stored Procedures",description:"Create reusable SQL programs",concepts:["Procedures","Parameters","Reusability"],lesson:{content:"# Stored Procedures ðŸ“¦\n\nStored procedures are saved SQL code that can be executed repeatedly.\n\n## Creating a Procedure (varies by database)\n```sql\n-- MySQL/PostgreSQL style\nCREATE PROCEDURE GetSurvivorsByClass(IN class_num INT)\nBEGIN\n    SELECT * FROM passengers \n    WHERE Pclass = class_num AND Survived = 1;\nEND;\n```\n\n## Benefits\n- Reusable code\n- Reduced network traffic\n- Better security\n- Encapsulation of business logic\n\n## SQLite Alternative\nSQLite doesn't support stored procedures, but you can:\n1. Use Views for reusable queries\n2. Use application code for complex logic\n3. Use triggers for automated actions\n\n## Simulating with Views\n```sql\n-- Create parameterized-like views\nCREATE VIEW first_class_survivors AS\nSELECT * FROM passengers WHERE Pclass = 1 AND Survived = 1;\n\nCREATE VIEW second_class_survivors AS\nSELECT * FROM passengers WHERE Pclass = 2 AND Survived = 1;\n```",tips:["Stored procedures reduce code duplication","They can accept input parameters","Great for complex, repeated operations"]},challenge:{title:"Reusable Query Design",description:"Design a query that could be a stored procedure: Find survivors from a specific class with their details. Use Pclass = 1 as example.",dataset:"titanic",solution:"SELECT PassengerId, Name, Sex, Age, Fare FROM passengers WHERE Pclass = 1 AND Survived = 1 ORDER BY Fare DESC;",hints:["Filter by Pclass and Survived","Select relevant columns","This pattern could accept Pclass as parameter"],points:20}},{day:19,week:3,title:"Triggers",description:"Automate actions on data changes",concepts:["CREATE TRIGGER","BEFORE/AFTER","Automation"],lesson:{content:"# Triggers - Automatic Actions ðŸŽ¯\n\nTriggers automatically execute code when data changes.\n\n## Trigger Types\n- BEFORE INSERT/UPDATE/DELETE\n- AFTER INSERT/UPDATE/DELETE\n\n## Example Trigger\n```sql\nCREATE TRIGGER log_fare_changes\nAFTER UPDATE ON passengers\nWHEN OLD.Fare != NEW.Fare\nBEGIN\n    INSERT INTO fare_log (passenger_id, old_fare, new_fare, changed_at)\n    VALUES (NEW.PassengerId, OLD.Fare, NEW.Fare, datetime('now'));\nEND;\n```\n\n## Use Cases\n- Audit logging\n- Automatic calculations\n- Data validation\n- Cascading updates\n\n## Special Values\n- NEW: The new row data\n- OLD: The previous row data\n\n## Caution\n- Triggers add hidden complexity\n- Can impact performance\n- Difficult to debug",tips:["Use triggers sparingly","Document all triggers thoroughly","Test trigger behavior carefully"]},challenge:{title:"Audit Query Design",description:"Write a query that shows what an audit log might track: Compare fare statistics before and after a hypothetical 10% increase.",dataset:"titanic",solution:"SELECT Pclass, AVG(Fare) AS current_avg_fare, AVG(Fare) * 1.1 AS projected_avg_fare, SUM(Fare) AS current_total, SUM(Fare) * 1.1 AS projected_total FROM passengers GROUP BY Pclass;",hints:["Show current and projected values","Multiply by 1.1 for 10% increase","GROUP BY class for comparison"],points:25}},{day:20,week:3,title:"Database Normalization",description:"Design efficient database structures",concepts:["1NF","2NF","3NF","Normalization"],lesson:{content:'# Database Normalization ðŸ“\n\nNormalization organizes data to reduce redundancy and improve integrity.\n\n## First Normal Form (1NF)\n- Each cell contains a single value\n- Each row is unique\n- No repeating groups\n\nâŒ Bad: "John, Jane" in one cell\nâœ… Good: Separate rows for John and Jane\n\n## Second Normal Form (2NF)\n- Must be in 1NF\n- All non-key columns depend on the entire primary key\n\nâŒ Bad: Order table with customer_name\nâœ… Good: Separate customers table, link by customer_id\n\n## Third Normal Form (3NF)\n- Must be in 2NF\n- No transitive dependencies\n\nâŒ Bad: employee table with dept_name\nâœ… Good: departments table linked by dept_id\n\n## Trade-offs\n- Normalized: Less redundancy, more joins\n- Denormalized: Fewer joins, some redundancy',tips:["Normalize for transaction systems (OLTP)","Denormalize for analytics (OLAP)","Balance between joins and redundancy"]},challenge:{title:"Data Structure Analysis",description:"The Titanic data has denormalized cabin info. Count how many passengers share cabins (same Cabin value, excluding empty).",dataset:"titanic",solution:"SELECT Cabin, COUNT(*) AS passengers FROM passengers WHERE Cabin IS NOT NULL AND Cabin != '' GROUP BY Cabin HAVING COUNT(*) > 1 ORDER BY passengers DESC;",hints:["GROUP BY Cabin","Filter out NULL/empty cabins","HAVING COUNT(*) > 1 for shared cabins"],points:25}},{day:21,week:3,title:"ACID Properties",description:"Understand database reliability guarantees",concepts:["Atomicity","Consistency","Isolation","Durability"],lesson:{content:"# ACID Properties ðŸ›¡ï¸\n\nACID ensures reliable database transactions.\n\n## Atomicity\nAll operations complete, or none do.\n```sql\n-- Transfer $100: both must succeed or both fail\nBEGIN;\nUPDATE accounts SET balance = balance - 100 WHERE id = 1;\nUPDATE accounts SET balance = balance + 100 WHERE id = 2;\nCOMMIT;\n```\n\n## Consistency\nDatabase moves from one valid state to another.\n- Constraints are enforced\n- Data integrity maintained\n\n## Isolation\nConcurrent transactions don't interfere.\n\nIsolation Levels:\n1. READ UNCOMMITTED (lowest)\n2. READ COMMITTED\n3. REPEATABLE READ\n4. SERIALIZABLE (highest)\n\n## Durability\nCommitted transactions survive system failures.\n- Write-ahead logging\n- Data persistence\n\n## Why ACID Matters\n- Financial transactions\n- Inventory management\n- User account operations",tips:["Higher isolation = less concurrency","Choose isolation level based on needs","ACID is critical for data integrity"]},challenge:{title:"Consistency Check",description:"Write a query to verify data consistency: Check that all Survived values are either 0 or 1 (no other values).",dataset:"titanic",solution:"SELECT Survived, COUNT(*) AS count FROM passengers GROUP BY Survived ORDER BY Survived;",hints:["GROUP BY Survived to see all values","Should only show 0 and 1","This validates data consistency"],points:20}},{day:22,week:4,title:"Date Functions",description:"Work with dates and times in SQL",concepts:["DATE","DATETIME","Date arithmetic"],lesson:{content:"# Date Functions ðŸ“…\n\n## Current Date/Time\n```sql\nSELECT date('now');           -- 2024-01-15\nSELECT datetime('now');       -- 2024-01-15 14:30:00\nSELECT time('now');           -- 14:30:00\n```\n\n## Date Arithmetic\n```sql\nSELECT date('now', '+7 days');      -- 7 days from now\nSELECT date('now', '-1 month');     -- 1 month ago\nSELECT date('now', 'start of year'); -- Jan 1 of current year\n```\n\n## Extracting Parts\n```sql\nSELECT strftime('%Y', date_column) AS year,\n       strftime('%m', date_column) AS month,\n       strftime('%d', date_column) AS day\nFROM table_name;\n```\n\n## Date Formatting\n```sql\nSELECT strftime('%Y-%m-%d', datetime_column) AS formatted_date;\nSELECT strftime('%H:%M', datetime_column) AS time_only;\n```\n\n## Date Comparisons\n```sql\nSELECT * FROM orders \nWHERE order_date >= date('now', '-30 days');\n```",tips:["SQLite stores dates as TEXT in ISO format","Use strftime for formatting","Always use consistent date formats"]},challenge:{title:"Date Analysis",description:"Using **ecommerce** dataset, find orders from the last 30 days (use date comparison with order_date).",dataset:"ecommerce",solution:"SELECT * FROM orders WHERE order_date >= date('now', '-30 days') ORDER BY order_date DESC;",hints:["Use date('now', '-30 days')","Compare with order_date","ORDER BY date descending for recent first"],points:25}},{day:23,week:4,title:"String Functions",description:"Manipulate text data effectively",concepts:["UPPER","LOWER","SUBSTR","TRIM","REPLACE"],lesson:{content:"# String Functions ðŸ“\n\n## Case Conversion\n```sql\nSELECT UPPER(Name) AS upper_name,\n       LOWER(Name) AS lower_name\nFROM passengers;\n```\n\n## Substring\n```sql\nSELECT SUBSTR(Name, 1, 10) AS first_10_chars\nFROM passengers;\n```\n\n## Length\n```sql\nSELECT Name, LENGTH(Name) AS name_length\nFROM passengers;\n```\n\n## Trim Whitespace\n```sql\nSELECT TRIM('  hello  ');     -- 'hello'\nSELECT LTRIM('  hello');      -- 'hello'\nSELECT RTRIM('hello  ');      -- 'hello'\n```\n\n## Replace\n```sql\nSELECT REPLACE(Name, 'Mr.', 'Mister')\nFROM passengers;\n```\n\n## Concatenation\n```sql\nSELECT Name || ' - Class ' || Pclass AS passenger_info\nFROM passengers;\n```\n\n## Pattern Matching (LIKE)\n```sql\nSELECT * FROM passengers WHERE Name LIKE '%Smith%';\nSELECT * FROM passengers WHERE Name LIKE 'A%';\n```",tips:["LIKE: % matches any characters, _ matches one character","String functions are case-sensitive","Use || for concatenation in SQLite"]},challenge:{title:"Extract Titles",description:"Extract passenger titles (Mr., Mrs., Miss., Master) from names. Count how many of each title exist.",dataset:"titanic",solution:"SELECT CASE WHEN Name LIKE '%Mr.%' THEN 'Mr.' WHEN Name LIKE '%Mrs.%' THEN 'Mrs.' WHEN Name LIKE '%Miss.%' THEN 'Miss.' WHEN Name LIKE '%Master.%' THEN 'Master' ELSE 'Other' END AS title, COUNT(*) AS count FROM passengers GROUP BY title ORDER BY count DESC;",hints:["Use LIKE for pattern matching","CASE WHEN to categorize","GROUP BY the extracted title"],points:30}},{day:24,week:4,title:"Math Functions",description:"Perform calculations in SQL",concepts:["ROUND","ABS","CEIL","FLOOR","MOD"],lesson:{content:"# Math Functions ðŸ”¢\n\n## Rounding\n```sql\nSELECT ROUND(3.14159, 2);     -- 3.14\nSELECT ROUND(Fare, 0) FROM passengers;\n```\n\n## Absolute Value\n```sql\nSELECT ABS(-42);              -- 42\n```\n\n## Min/Max per Row\n```sql\nSELECT MAX(Age, Fare) AS greater_value\nFROM passengers;\n```\n\n## Modulo (Remainder)\n```sql\nSELECT PassengerId, PassengerId % 10 AS last_digit\nFROM passengers;\n```\n\n## Practical Calculations\n```sql\nSELECT \n    Fare,\n    ROUND(Fare * 1.1, 2) AS fare_plus_10_percent,\n    ROUND(Fare / 100, 2) AS fare_in_hundreds\nFROM passengers;\n```\n\n## Statistical Calculations\n```sql\nSELECT \n    AVG(Fare) AS mean_fare,\n    MIN(Fare) AS min_fare,\n    MAX(Fare) AS max_fare,\n    MAX(Fare) - MIN(Fare) AS fare_range\nFROM passengers;\n```",tips:["ROUND(value, decimals) rounds to specified places","Division by integers truncates - use 1.0 for decimals","Combine math with aggregates for statistics"]},challenge:{title:"Fare Statistics",description:"Calculate fare statistics by class: average, min, max, and range (max - min). Round to 2 decimal places.",dataset:"titanic",solution:"SELECT Pclass, ROUND(AVG(Fare), 2) AS avg_fare, ROUND(MIN(Fare), 2) AS min_fare, ROUND(MAX(Fare), 2) AS max_fare, ROUND(MAX(Fare) - MIN(Fare), 2) AS fare_range FROM passengers GROUP BY Pclass ORDER BY Pclass;",hints:["GROUP BY Pclass","Use ROUND(..., 2) for all values","Range = MAX - MIN"],points:25}},{day:25,week:4,title:"Window Functions",description:"Perform calculations across row sets",concepts:["OVER","PARTITION BY","ROW_NUMBER","RANK"],lesson:{content:"# Window Functions ðŸªŸ\n\nWindow functions perform calculations across a set of rows related to the current row.\n\n## ROW_NUMBER\n```sql\nSELECT Name, Fare,\n       ROW_NUMBER() OVER (ORDER BY Fare DESC) AS fare_rank\nFROM passengers;\n```\n\n## PARTITION BY\nSeparate windows for each group:\n```sql\nSELECT Name, Pclass, Fare,\n       ROW_NUMBER() OVER (PARTITION BY Pclass ORDER BY Fare DESC) AS rank_in_class\nFROM passengers;\n```\n\n## RANK and DENSE_RANK\n```sql\nSELECT Name, Fare,\n       RANK() OVER (ORDER BY Fare DESC) AS rank,\n       DENSE_RANK() OVER (ORDER BY Fare DESC) AS dense_rank\nFROM passengers;\n```\n\n## Running Totals\n```sql\nSELECT Name, Fare,\n       SUM(Fare) OVER (ORDER BY PassengerId) AS running_total\nFROM passengers;\n```\n\n## Moving Averages\n```sql\nSELECT Name, Fare,\n       AVG(Fare) OVER (ORDER BY PassengerId \n                       ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) AS moving_avg\nFROM passengers;\n```",tips:["Window functions don't collapse rows like GROUP BY","PARTITION BY creates separate 'windows'","ORDER BY within OVER determines row ordering"]},challenge:{title:"Rank Within Class",description:"Rank passengers by fare within each class. Show Name, Pclass, Fare, and rank_in_class.",dataset:"titanic",solution:"SELECT Name, Pclass, Fare, RANK() OVER (PARTITION BY Pclass ORDER BY Fare DESC) AS rank_in_class FROM passengers WHERE Fare > 0;",hints:["Use RANK() or ROW_NUMBER()","PARTITION BY Pclass","ORDER BY Fare DESC for highest first"],points:30}},{day:26,week:4,title:"Common Table Expressions (CTEs)",description:"Write cleaner, more readable queries",concepts:["WITH clause","CTEs","Recursive CTEs"],lesson:{content:"# CTEs - Common Table Expressions ðŸ“‹\n\nCTEs create temporary named result sets for cleaner queries.\n\n## Basic CTE\n```sql\nWITH survivors AS (\n    SELECT * FROM passengers WHERE Survived = 1\n)\nSELECT Pclass, COUNT(*) AS survivor_count\nFROM survivors\nGROUP BY Pclass;\n```\n\n## Multiple CTEs\n```sql\nWITH \nsurvivors AS (\n    SELECT * FROM passengers WHERE Survived = 1\n),\nclass_stats AS (\n    SELECT Pclass, AVG(Age) AS avg_age\n    FROM survivors\n    GROUP BY Pclass\n)\nSELECT * FROM class_stats;\n```\n\n## CTE vs Subquery\n```sql\n-- CTE (more readable)\nWITH high_fare AS (\n    SELECT * FROM passengers WHERE Fare > 100\n)\nSELECT * FROM high_fare WHERE Age > 50;\n\n-- Equivalent subquery (harder to read)\nSELECT * FROM (\n    SELECT * FROM passengers WHERE Fare > 100\n) WHERE Age > 50;\n```\n\n## Benefits\n- Improved readability\n- Reusable within the query\n- Self-referencing (recursive)",tips:["CTEs make complex queries more readable","Each CTE can reference previous ones","Great for breaking down complex logic"]},challenge:{title:"CTE Analysis",description:"Use a CTE to find: First, passengers who paid above-average fare, then calculate survival rate for this group.",dataset:"titanic",solution:"WITH high_fare_passengers AS (SELECT * FROM passengers WHERE Fare > (SELECT AVG(Fare) FROM passengers)) SELECT COUNT(*) AS total, SUM(Survived) AS survived, ROUND(AVG(Survived) * 100, 1) AS survival_rate FROM high_fare_passengers;",hints:["First CTE: passengers with Fare > AVG(Fare)","Main query: aggregate stats from the CTE","Calculate survival rate as AVG(Survived) * 100"],points:30}},{day:27,week:4,title:"Analytic Functions",description:"Advanced analytics with SQL",concepts:["LAG","LEAD","FIRST_VALUE","LAST_VALUE"],lesson:{content:"# Analytic Functions ðŸ“Š\n\nAccess data from other rows without self-joins.\n\n## LAG - Previous Row\n```sql\nSELECT Name, Fare,\n       LAG(Fare) OVER (ORDER BY PassengerId) AS prev_fare,\n       Fare - LAG(Fare) OVER (ORDER BY PassengerId) AS fare_diff\nFROM passengers;\n```\n\n## LEAD - Next Row\n```sql\nSELECT Name, Fare,\n       LEAD(Fare) OVER (ORDER BY PassengerId) AS next_fare\nFROM passengers;\n```\n\n## FIRST_VALUE / LAST_VALUE\n```sql\nSELECT Name, Pclass, Fare,\n       FIRST_VALUE(Name) OVER (PARTITION BY Pclass ORDER BY Fare DESC) AS highest_fare_passenger\nFROM passengers;\n```\n\n## NTH_VALUE\n```sql\nSELECT Name, Fare,\n       NTH_VALUE(Name, 3) OVER (ORDER BY Fare DESC) AS third_highest\nFROM passengers;\n```\n\n## Practical Use Cases\n- Compare to previous period\n- Calculate differences\n- Find first/last in group",tips:["LAG/LEAD accept optional offset and default parameters","FIRST_VALUE is useful for 'best in class' queries","Combine with PARTITION BY for group-level analysis"]},challenge:{title:"Fare Comparison",description:"For each passenger, show their fare and the fare of the next more expensive ticket (using LEAD).",dataset:"titanic",solution:"SELECT Name, Fare, LEAD(Fare) OVER (ORDER BY Fare) AS next_higher_fare, LEAD(Fare) OVER (ORDER BY Fare) - Fare AS fare_gap FROM passengers WHERE Fare > 0 ORDER BY Fare;",hints:["Use LEAD with ORDER BY Fare","Calculate the gap as next - current","Filter out zero fares"],points:30}},{day:28,week:4,title:"Pivot & Unpivot",description:"Transform data between rows and columns",concepts:["PIVOT","UNPIVOT","Cross-tabulation"],lesson:{content:"# Pivot & Unpivot ðŸ”„\n\nTransform between row and column layouts.\n\n## Manual Pivot with CASE\n```sql\nSELECT \n    Pclass,\n    SUM(CASE WHEN Survived = 1 THEN 1 ELSE 0 END) AS survived,\n    SUM(CASE WHEN Survived = 0 THEN 1 ELSE 0 END) AS died\nFROM passengers\nGROUP BY Pclass;\n```\n\n## Gender by Class Pivot\n```sql\nSELECT \n    Pclass,\n    SUM(CASE WHEN Sex = 'male' THEN 1 ELSE 0 END) AS male,\n    SUM(CASE WHEN Sex = 'female' THEN 1 ELSE 0 END) AS female\nFROM passengers\nGROUP BY Pclass;\n```\n\n## Cross-Tabulation\n```sql\nSELECT \n    CASE WHEN Age < 18 THEN 'Child' ELSE 'Adult' END AS age_group,\n    SUM(CASE WHEN Survived = 1 THEN 1 ELSE 0 END) AS survived,\n    SUM(CASE WHEN Survived = 0 THEN 1 ELSE 0 END) AS died\nFROM passengers\nWHERE Age IS NOT NULL\nGROUP BY age_group;\n```\n\n## Why Pivot?\n- Create reports\n- Compare categories side-by-side\n- Prepare data for visualization",tips:["SQLite doesn't have native PIVOT - use CASE","Pivoting is great for creating dashboards","Unpivot normalizes wide tables"]},challenge:{title:"Survival Cross-Tab",description:"Create a pivot table showing survival counts by **Pclass (rows)** and **Sex (columns)**.",dataset:"titanic",solution:"SELECT Pclass, SUM(CASE WHEN Sex = 'male' AND Survived = 1 THEN 1 ELSE 0 END) AS male_survived, SUM(CASE WHEN Sex = 'male' AND Survived = 0 THEN 1 ELSE 0 END) AS male_died, SUM(CASE WHEN Sex = 'female' AND Survived = 1 THEN 1 ELSE 0 END) AS female_survived, SUM(CASE WHEN Sex = 'female' AND Survived = 0 THEN 1 ELSE 0 END) AS female_died FROM passengers GROUP BY Pclass ORDER BY Pclass;",hints:["Use CASE WHEN with AND for combinations","Four columns: male_survived, male_died, female_survived, female_died","GROUP BY Pclass"],points:35}},{day:29,week:5,title:"Index Optimization",description:"Optimize queries with proper indexing",concepts:["Index strategies","Query optimization","EXPLAIN"],lesson:{content:"# Index Optimization âš¡\n\n## Query Execution Plans\nSee how a query runs:\n```sql\nEXPLAIN QUERY PLAN\nSELECT * FROM passengers WHERE Age > 30;\n```\n\n## Index Strategies\n\n### Single-Column Index\n```sql\nCREATE INDEX idx_age ON passengers(Age);\n-- Good for: WHERE Age > 30\n```\n\n### Composite Index\n```sql\nCREATE INDEX idx_class_age ON passengers(Pclass, Age);\n-- Good for: WHERE Pclass = 1 AND Age > 30\n-- Also works for: WHERE Pclass = 1\n-- Doesn't help: WHERE Age > 30 (not leftmost)\n```\n\n### Covering Index\nInclude all columns needed:\n```sql\nCREATE INDEX idx_covering ON passengers(Pclass, Age, Name);\n-- Query can use index without touching table\n```\n\n## What Prevents Index Use\n- Functions on indexed column: WHERE UPPER(Name) = 'JOHN'\n- OR with different columns\n- NOT IN, NOT EXISTS (sometimes)\n- Leading wildcard: LIKE '%Smith'",tips:["EXPLAIN QUERY PLAN shows if indexes are used","Leftmost column in composite index is most important","Too many indexes slow down writes"]},challenge:{title:"Query Analysis",description:"Write an optimized query that would benefit from a composite index on (Pclass, Survived): Find survival rate by class.",dataset:"titanic",solution:"SELECT Pclass, COUNT(*) AS total, SUM(Survived) AS survived, ROUND(AVG(Survived) * 100, 2) AS survival_rate FROM passengers GROUP BY Pclass ORDER BY Pclass;",hints:["GROUP BY Pclass uses the index","Survived in aggregate can use index","This query pattern is index-friendly"],points:30}},{day:30,week:5,title:"Query Performance Tuning",description:"Master techniques for fast, efficient queries",concepts:["Performance tuning","Best practices","Query optimization"],lesson:{content:"# Query Performance Tuning ðŸ†\n\n## Key Optimization Techniques\n\n### 1. Select Only What You Need\n```sql\n-- Bad\nSELECT * FROM passengers WHERE Pclass = 1;\n\n-- Good\nSELECT Name, Age, Fare FROM passengers WHERE Pclass = 1;\n```\n\n### 2. Use WHERE to Filter Early\n```sql\n-- Bad\nSELECT * FROM passengers HAVING Age > 30;\n\n-- Good\nSELECT * FROM passengers WHERE Age > 30;\n```\n\n### 3. Avoid Functions on Indexed Columns\n```sql\n-- Bad (can't use index)\nSELECT * FROM passengers WHERE UPPER(Name) LIKE 'SMITH%';\n\n-- Good (uses index)\nSELECT * FROM passengers WHERE Name LIKE 'Smith%';\n```\n\n### 4. Use EXISTS Instead of IN (for large sets)\n```sql\n-- Often slower\nSELECT * FROM passengers WHERE Pclass IN (SELECT Pclass FROM ...);\n\n-- Often faster\nSELECT * FROM passengers p WHERE EXISTS (SELECT 1 FROM ... WHERE Pclass = p.Pclass);\n```\n\n### 5. Optimize JOINs\n- Join on indexed columns\n- Start with smaller table\n- Filter before joining when possible\n\n## Performance Checklist\nâœ… SELECT only needed columns\nâœ… Use appropriate indexes\nâœ… Filter early with WHERE\nâœ… Avoid SELECT DISTINCT if possible\nâœ… Use LIMIT for large results",tips:["Measure before optimizing","The best optimization is not running unnecessary queries","Database design impacts performance more than query tuning"]},challenge:{title:"Final Challenge: Complete Analysis",description:"Write an optimized, comprehensive analysis: Show passenger class, gender, count, survivors, survival rate, avg fare, and avg age - all in one efficient query!",dataset:"titanic",solution:"SELECT Pclass, Sex, COUNT(*) AS total, SUM(Survived) AS survivors, ROUND(AVG(Survived) * 100, 1) AS survival_rate, ROUND(AVG(Fare), 2) AS avg_fare, ROUND(AVG(Age), 1) AS avg_age FROM passengers WHERE Age IS NOT NULL GROUP BY Pclass, Sex ORDER BY Pclass, Sex;",hints:["GROUP BY Pclass, Sex","Multiple aggregates in one query","Filter NULL ages for accurate averages"],points:50}}],rewards:{daily:25,weekComplete:100,perfectDay:10,challengeComplete:500,speedBonus:50}};